["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/js-yaml/lib/dumper.js"],"~:js","shadow$provide[30]=function(P,ta,ka){function V(E){this.schema=E.schema||gb;this.indent=Math.max(1,E.indent||2);this.noArrayIndent=E.noArrayIndent||!1;this.skipInvalid=E.skipInvalid||!1;this.flowLevel=kb.isNothing(E.flowLevel)?-1:E.flowLevel;var Y=this.schema;var qa=E.styles||null,Aa,va;if(qa===null)Y={};else{var Fa={};var ma=Object.keys(qa);var Ja=0;for(Aa=ma.length;Ja<Aa;Ja+=1){var Va=ma[Ja];var r=String(qa[Va]);Va.slice(0,2)===\"!!\"&&(Va=\"tag:yaml.org,2002:\"+Va.slice(2));(va=Y.compiledTypeMap.fallback[Va])&&\nea.call(va.styleAliases,r)&&(r=va.styleAliases[r]);Fa[Va]=r}Y=Fa}this.styleMap=Y;this.sortKeys=E.sortKeys||!1;this.lineWidth=E.lineWidth||80;this.noRefs=E.noRefs||!1;this.noCompatMode=E.noCompatMode||!1;this.condenseFlow=E.condenseFlow||!1;this.quotingType=E.quotingType==='\"'?2:1;this.forceQuotes=E.forceQuotes||!1;this.replacer=typeof E.replacer===\"function\"?E.replacer:null;this.implicitTypes=this.schema.compiledImplicit;this.explicitTypes=this.schema.compiledExplicit;this.tag=null;this.result=\"\";\nthis.duplicates=[];this.usedDuplicates=null}function J(E,Y){Y=kb.repeat(\" \",Y);for(var qa=0,Aa,va=\"\",Fa,ma=E.length;qa<ma;)Aa=E.indexOf(\"\\n\",qa),Aa===-1?(Fa=E.slice(qa),qa=ma):(Fa=E.slice(qa,Aa+1),qa=Aa+1),Fa.length&&Fa!==\"\\n\"&&(va+=Y),va+=Fa;return va}function N(E){return 32<=E&&E<=126||161<=E&&E<=55295&&E!==8232&&E!==8233||57344<=E&&E<=65533&&E!==65279||65536<=E&&E<=1114111}function L(E){return N(E)&&E!==65279&&E!==13&&E!==10}function I(E,Y,qa){var Aa=L(E),va=Aa&&!(E===32||E===9);return(qa?Aa:Aa&&\nE!==44&&E!==91&&E!==93&&E!==123&&E!==125)&&E!==35&&!(Y===58&&!va)||L(Y)&&!(Y===32||Y===9)&&E===35||Y===58&&va}function H(E,Y){var qa=E.charCodeAt(Y);return qa>=55296&&qa<=56319&&Y+1<E.length&&(E=E.charCodeAt(Y+1),E>=56320&&E<=57343)?(qa-55296)*1024+E-56320+65536:qa}function W(E,Y,qa,Aa,va,Fa,ma,Ja){var Va=null,r=!1,A=!1,O=Aa!==-1,G=-1,T=H(E,0);if(T=N(T)&&T!==65279&&!(T===32||T===9)&&T!==45&&T!==63&&T!==58&&T!==44&&T!==91&&T!==93&&T!==123&&T!==125&&T!==35&&T!==38&&T!==42&&T!==33&&T!==124&&T!==61&&\nT!==62&&T!==39&&T!==34&&T!==37&&T!==64&&T!==96)T=H(E,E.length-1),T=!(T===32||T===9)&&T!==58;if(Y||ma)for(Y=0;Y<E.length;ca>=65536?Y+=2:Y++){var ca=H(E,Y);if(!N(ca))return 5;T=T&&I(ca,Va,Ja);Va=ca}else{for(Y=0;Y<E.length;ca>=65536?Y+=2:Y++){ca=H(E,Y);if(ca===10)r=!0,O&&(A=A||Y-G-1>Aa&&E[G+1]!==\" \",G=Y);else if(!N(ca))return 5;T=T&&I(ca,Va,Ja);Va=ca}A=A||O&&Y-G-1>Aa&&E[G+1]!==\" \"}return r||A?qa>9&&/^\\n* /.test(E)?5:ma?Fa===2?5:2:A?4:3:!T||ma||va(E)?Fa===2?5:2:1}function D(E,Y,qa,Aa,va){E.dump=function(){if(Y.length===\n0)return E.quotingType===2?'\"\"':\"''\";if(!E.noCompatMode&&(Sa.indexOf(Y)!==-1||fb.test(Y)))return E.quotingType===2?'\"'+Y+'\"':\"'\"+Y+\"'\";var Fa=E.indent*Math.max(1,qa),ma=E.lineWidth===-1?-1:Math.max(Math.min(E.lineWidth,40),E.lineWidth-Fa);switch(W(Y,Aa||E.flowLevel>-1&&qa>=E.flowLevel,E.indent,ma,function(Ja){a:{var Va;var r=0;for(Va=E.implicitTypes.length;r<Va;r+=1){var A=E.implicitTypes[r];if(A.resolve(Ja)){Ja=!0;break a}}Ja=!1}return Ja},E.quotingType,E.forceQuotes&&!Aa,va)){case 1:return Y;case 2:return\"'\"+\nY.replace(/'/g,\"''\")+\"'\";case 3:return\"|\"+F(Y,E.indent)+U(J(Y,Fa));case 4:return\"\\x3e\"+F(Y,E.indent)+U(J(ha(Y,ma),Fa));case 5:return'\"'+Pa(Y,ma)+'\"';default:throw new pb(\"impossible error: invalid scalar style\");}}()}function F(E,Y){Y=/^\\n* /.test(E)?String(Y):\"\";var qa=E[E.length-1]===\"\\n\";return Y+(!qa||E[E.length-2]!==\"\\n\"&&E!==\"\\n\"?qa?\"\":\"-\":\"+\")+\"\\n\"}function U(E){return E[E.length-1]===\"\\n\"?E.slice(0,-1):E}function ha(E,Y){var qa=/(\\n+)([^\\n]*)/g;var Aa=E.indexOf(\"\\n\");Aa=Aa!==-1?Aa:E.length;\nqa.lastIndex=Aa;Aa=za(E.slice(0,Aa),Y);for(var va=E[0]===\"\\n\"||E[0]===\" \",Fa;Fa=qa.exec(E);){var ma=Fa[1],Ja=Fa[2];Fa=Ja[0]===\" \";Aa+=ma+(va||Fa||Ja===\"\"?\"\":\"\\n\")+za(Ja,Y);va=Fa}return Aa}function za(E,Y){if(E===\"\"||E[0]===\" \")return E;var qa=/ [^ ]/g,Aa,va=0;var Fa=0;for(var ma=\"\";Aa=qa.exec(E);)Aa=Aa.index,Aa-va>Y&&(Fa=Fa>va?Fa:Aa,ma+=\"\\n\"+E.slice(va,Fa),va=Fa+1),Fa=Aa;ma+=\"\\n\";ma=E.length-va>Y&&Fa>va?ma+(E.slice(va,Fa)+\"\\n\"+E.slice(Fa+1)):ma+E.slice(va);return ma.slice(1)}function Pa(E){for(var Y=\n\"\",qa,Aa,va=0;va<E.length;qa>=65536?va+=2:va++)if(qa=H(E,va),Aa=La[qa],!Aa&&N(qa))Y+=E[va],qa>=65536&&(Y+=E[va+1]);else{if(!Aa){var Fa=qa;Aa=Fa.toString(16).toUpperCase();if(Fa<=255){var ma=\"x\";Fa=2}else if(Fa<=65535)ma=\"u\",Fa=4;else if(Fa<=4294967295)ma=\"U\",Fa=8;else throw new pb(\"code point within a string may not be greater than 0xFFFFFFFF\");Aa=\"\\\\\"+ma+kb.repeat(\"0\",Fa-Aa.length)+Aa}Y+=Aa}return Y}function Oa(E,Y,qa,Aa){var va=\"\",Fa=E.tag,ma;var Ja=0;for(ma=qa.length;Ja<ma;Ja+=1){var Va=qa[Ja];\nE.replacer&&(Va=E.replacer.call(qa,String(Ja),Va));if(Ca(E,Y+1,Va,!0,!0,!1,!0)||typeof Va===\"undefined\"&&Ca(E,Y+1,null,!0,!0,!1,!0))Aa&&va===\"\"||(va+=\"\\n\"+kb.repeat(\" \",E.indent*Y)),va=E.dump&&10===E.dump.charCodeAt(0)?va+\"-\":va+\"- \",va+=E.dump}E.tag=Fa;E.dump=va||\"[]\"}function xa(E,Y,qa){var Aa;var va=qa?E.explicitTypes:E.implicitTypes;var Fa=0;for(Aa=va.length;Fa<Aa;Fa+=1){var ma=va[Fa];if((ma.instanceOf||ma.predicate)&&(!ma.instanceOf||typeof Y===\"object\"&&Y instanceof ma.instanceOf)&&(!ma.predicate||\nma.predicate(Y))){E.tag=qa?ma.multi&&ma.representName?ma.representName(Y):ma.tag:\"?\";if(ma.represent){qa=E.styleMap[ma.tag]||ma.defaultStyle;if(X.call(ma.represent)===\"[object Function]\")Y=ma.represent(Y,qa);else if(ea.call(ma.represent,qa))Y=ma.represent[qa](Y,qa);else throw new pb(\"!\\x3c\"+ma.tag+'\\x3e tag resolver accepts not \"'+qa+'\" style');E.dump=Y}return!0}}return!1}function Ca(E,Y,qa,Aa,va,Fa,ma){E.tag=null;E.dump=qa;xa(E,qa,!1)||xa(E,qa,!0);var Ja=X.call(E.dump),Va=Aa;Aa&&(Aa=E.flowLevel<\n0||E.flowLevel>Y);var r=Ja===\"[object Object]\"||Ja===\"[object Array]\";if(r){var A=E.duplicates.indexOf(qa);var O=A!==-1}if(E.tag!==null&&E.tag!==\"?\"||O||E.indent!==2&&Y>0)va=!1;if(O&&E.usedDuplicates[A])E.dump=\"*ref_\"+A;else{r&&O&&!E.usedDuplicates[A]&&(E.usedDuplicates[A]=!0);if(Ja===\"[object Object]\")if(Aa&&Object.keys(E.dump).length!==0){qa=E.dump;Aa=\"\";Fa=E.tag;ma=Object.keys(qa);if(E.sortKeys===!0)ma.sort();else if(typeof E.sortKeys===\"function\")ma.sort(E.sortKeys);else if(E.sortKeys)throw new pb(\"sortKeys must be a boolean or a function\");\nJa=0;for(Va=ma.length;Ja<Va;Ja+=1){var G=\"\";va&&Aa===\"\"||(G+=\"\\n\"+kb.repeat(\" \",E.indent*Y));var T=ma[Ja];r=qa[T];E.replacer&&(r=E.replacer.call(qa,T,r));Ca(E,Y+1,T,!0,!0,!0)&&((T=E.tag!==null&&E.tag!==\"?\"||E.dump&&E.dump.length>1024)&&(G=E.dump&&10===E.dump.charCodeAt(0)?G+\"?\":G+\"? \"),G+=E.dump,T&&(G+=\"\\n\"+kb.repeat(\" \",E.indent*Y)),Ca(E,Y+1,r,!0,T)&&(G=E.dump&&10===E.dump.charCodeAt(0)?G+\":\":G+\": \",G+=E.dump,Aa+=G))}E.tag=Fa;E.dump=Aa||\"{}\";O&&(E.dump=\"\\x26ref_\"+A+E.dump)}else{qa=E.dump;va=\"\";Aa=\nE.tag;Fa=Object.keys(qa);ma=0;for(Ja=Fa.length;ma<Ja;ma+=1)G=\"\",va!==\"\"&&(G+=\", \"),E.condenseFlow&&(G+='\"'),Va=Fa[ma],r=qa[Va],E.replacer&&(r=E.replacer.call(qa,Va,r)),Ca(E,Y,Va,!1,!1)&&(E.dump.length>1024&&(G+=\"? \"),G+=E.dump+(E.condenseFlow?'\"':\"\")+\":\"+(E.condenseFlow?\"\":\" \"),Ca(E,Y,r,!1,!1)&&(G+=E.dump,va+=G));E.tag=Aa;E.dump=\"{\"+va+\"}\";O&&(E.dump=\"\\x26ref_\"+A+\" \"+E.dump)}else if(Ja===\"[object Array]\")if(Aa&&E.dump.length!==0)E.noArrayIndent&&!ma&&Y>0?Oa(E,Y-1,E.dump,va):Oa(E,Y,E.dump,va),O&&(E.dump=\n\"\\x26ref_\"+A+E.dump);else{qa=E.dump;va=\"\";Aa=E.tag;Fa=0;for(ma=qa.length;Fa<ma;Fa+=1)if(Ja=qa[Fa],E.replacer&&(Ja=E.replacer.call(qa,String(Fa),Ja)),Ca(E,Y,Ja,!1,!1)||typeof Ja===\"undefined\"&&Ca(E,Y,null,!1,!1))va!==\"\"&&(va+=\",\"+(E.condenseFlow?\"\":\" \")),va+=E.dump;E.tag=Aa;E.dump=\"[\"+va+\"]\";O&&(E.dump=\"\\x26ref_\"+A+\" \"+E.dump)}else if(Ja===\"[object String]\")E.tag!==\"?\"&&D(E,E.dump,Y,Fa,Va);else{if(Ja===\"[object Undefined]\"||E.skipInvalid)return!1;throw new pb(\"unacceptable kind of an object to dump \"+\nJa);}E.tag!==null&&E.tag!==\"?\"&&(Y=encodeURI(E.tag[0]===\"!\"?E.tag.slice(1):E.tag).replace(/!/g,\"%21\"),Y=E.tag[0]===\"!\"?\"!\"+Y:Y.slice(0,18)===\"tag:yaml.org,2002:\"?\"!!\"+Y.slice(18):\"!\\x3c\"+Y+\"\\x3e\",E.dump=Y+\" \"+E.dump)}return!0}function Ka(E,Y,qa){var Aa;if(E!==null&&typeof E===\"object\"){var va=Y.indexOf(E);if(va!==-1)qa.indexOf(va)===-1&&qa.push(va);else if(Y.push(E),Array.isArray(E))for(va=0,Aa=E.length;va<Aa;va+=1)Ka(E[va],Y,qa);else{var Fa=Object.keys(E);va=0;for(Aa=Fa.length;va<Aa;va+=1)Ka(E[Fa[va]],\nY,qa)}}}var kb=P(7),pb=P(8),gb=P(28),X=Object.prototype.toString,ea=Object.prototype.hasOwnProperty,La={0:\"\\\\0\",7:\"\\\\a\",8:\"\\\\b\",9:\"\\\\t\",10:\"\\\\n\",11:\"\\\\v\",12:\"\\\\f\",13:\"\\\\r\",27:\"\\\\e\",34:'\\\\\"',92:\"\\\\\\\\\",133:\"\\\\N\",160:\"\\\\_\",8232:\"\\\\L\",8233:\"\\\\P\"},Sa=\"y Y yes Yes YES on On ON n N no No NO off Off OFF\".split(\" \"),fb=/^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;ta.exports.dump=function(E,Y){Y=Y||{};Y=new V(Y);if(!Y.noRefs){var qa=[],Aa=[],va;Ka(E,qa,Aa);var Fa=0;for(va=Aa.length;Fa<va;Fa+=1)Y.duplicates.push(qa[Aa[Fa]]);\nY.usedDuplicates=Array(va)}Y.replacer&&(E=Y.replacer.call({\"\":E},\"\",E));return Ca(Y,0,E,!0,!0)?Y.dump+\"\\n\":\"\"}}","~:source","shadow$provide[30] = function(require,module,exports) {\n'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nmodule.exports.dump = dump;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$js_yaml$lib$schema$default","~$module$node_modules$js_yaml$lib$common","~$shadow.js","~$module$node_modules$js_yaml$lib$exception"]],"~:properties",["^5",["flowLevel","lineWidth","sortKeys","condenseFlow","noCompatMode","schema","lastIndex","explicitTypes","implicitTypes","tag","usedDuplicates","indent","forceQuotes","dump","skipInvalid","styleMap","noArrayIndent","quotingType","replacer","noRefs","duplicates","result"]],"~:compiled-at",1751714332186,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$js_yaml$lib$dumper.js\",\n\"lineCount\":18,\n\"mappings\":\"AAAAA,cAAA,CAAe,EAAf,CAAA,CAAqB,QAAQ,CAACC,CAAD,CAASC,EAAT,CAAgBC,EAAhB,CAAyB,CAmHtDC,QAASA,EAAK,CAACC,CAAD,CAAU,CACtB,IAAKC,CAAAA,MAAL,CAAqBD,CAAA,CAAA,MAArB,EAA0CE,EAC1C,KAAKC,CAAAA,MAAL,CAAqBC,IAAKC,CAAAA,GAAL,CAAS,CAAT,CAAaL,CAAA,CAAA,MAAb,EAAkC,CAAlC,CACrB,KAAKM,CAAAA,aAAL,CAAqBN,CAAA,CAAA,aAArB,EAAiD,CAAA,CACjD,KAAKO,CAAAA,WAAL,CAAqBP,CAAA,CAAA,WAArB,EAA+C,CAAA,CAC/C,KAAKQ,CAAAA,SAAL,CAAsBC,EAAOC,CAAAA,SAAP,CAAiBV,CAAA,CAAA,SAAjB,CAAA,CAAyC,CAAC,CAA1C,CAA8CA,CAAA,CAAA,SAC1BC,KAAAA,EAALA,IAAKA,CAAAA,MAAQ,KAAA,GAAAD,CAAA,CAAA,MAAA,EAAqB,IAArB,CAzDzBW,EAyDyB,CAzDLC,EAE7C,IAAIC,EAAJ,GAAY,IAAZ,CAAkB,CAAA,CAAO,EAAzB,KAAA,CAEA,IAAAC,GAAS,EACT,KAAAC,GAAOC,MAAOD,CAAAA,IAAP,CAAYF,EAAZ,CAEF,KAAAI,GAAQ,CAAb,KAAgBN,EAAhB,CAAyBI,EAAKJ,CAAAA,MAA9B,CAAsCM,EAAtC,CAA8CN,EAA9C,CAAsDM,EAAtD,EAA+D,CAA/D,CAAkE,CAChE,IAAAC,GAAMH,EAAA,CAAKE,EAAL,CACN,KAAAE,EAAQC,MAAA,CAAOP,EAAA,CAAIK,EAAJ,CAAP,CAEJA,GAAIG,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CAAJ,GAAwB,IAAxB,GACEH,EADF,CACQ,oBADR,CAC+BA,EAAIG,CAAAA,KAAJ,CAAU,CAAV,CAD/B,CAKA,EAFAT,EAEA,CAFOX,CAAOqB,CAAAA,eAAP,CAAA,QAAA,CAAmCJ,EAAnC,CAEP;AAAYK,EAAgBC,CAAAA,IAAhB,CAAqBZ,EAAKa,CAAAA,YAA1B,CAAwCN,CAAxC,CAAZ,GACEA,CADF,CACUP,EAAKa,CAAAA,YAAL,CAAkBN,CAAlB,CADV,CAIAL,GAAA,CAAOI,EAAP,CAAA,CAAcC,CAbkD,CAgBlE,CAAA,CAAOL,EArBP,CAuDA,IAAKY,CAAAA,QAAL,CAAqB,CACrB,KAAKC,CAAAA,QAAL,CAAqB3B,CAAA,CAAA,QAArB,EAA4C,CAAA,CAC5C,KAAK4B,CAAAA,SAAL,CAAqB5B,CAAA,CAAA,SAArB,EAA6C,EAC7C,KAAK6B,CAAAA,MAAL,CAAqB7B,CAAA,CAAA,MAArB,EAA0C,CAAA,CAC1C,KAAK8B,CAAAA,YAAL,CAAqB9B,CAAA,CAAA,YAArB,EAAgD,CAAA,CAChD,KAAK+B,CAAAA,YAAL,CAAqB/B,CAAA,CAAA,YAArB,EAAgD,CAAA,CAChD,KAAKgC,CAAAA,WAAL,CAAqBhC,CAAA,CAAA,WAAA,GAA2B,GAA3B,CAdGiC,CAcH,CAfGC,CAgBxB,KAAKC,CAAAA,WAAL,CAAqBnC,CAAA,CAAA,WAArB,EAA+C,CAAA,CAC/C,KAAKoC,CAAAA,QAAL,CAAqB,MAAOpC,EAAA,CAAA,QAAP,GAA+B,UAA/B,CAA4CA,CAAA,CAAA,QAA5C,CAAkE,IAEvF,KAAKqC,CAAAA,aAAL,CAAqB,IAAKpC,CAAAA,MAAOqC,CAAAA,gBACjC,KAAKC,CAAAA,aAAL,CAAqB,IAAKtC,CAAAA,MAAOuC,CAAAA,gBAEjC,KAAKtB,CAAAA,GAAL,CAAW,IACX,KAAKJ,CAAAA,MAAL,CAAc,EAEd;IAAK2B,CAAAA,UAAL,CAAkB,EAClB,KAAKC,CAAAA,cAAL,CAAsB,IAvBA,CA2BxBC,QAASA,EAAY,CAACC,CAAD,CAASC,CAAT,CAAiB,CAChCC,CAAAA,CAAMrC,EAAOsC,CAAAA,MAAP,CAAc,GAAd,CAAmBF,CAAnB,CAOV,KARoC,IAEhCG,GAAW,CAFqB,CAGhCC,EAHgC,CAIhCnC,GAAS,EAJuB,CAKhCoC,EALgC,CAMhCvC,GAASiC,CAAOjC,CAAAA,MAEpB,CAAOqC,EAAP,CAAkBrC,EAAlB,CAAA,CACEsC,EAWA,CAXOL,CAAOO,CAAAA,OAAP,CAAe,IAAf,CAAqBH,EAArB,CAWP,CAVIC,EAAJ,GAAa,CAAC,CAAd,EACEC,EACA,CADON,CAAOvB,CAAAA,KAAP,CAAa2B,EAAb,CACP,CAAAA,EAAA,CAAWrC,EAFb,GAIEuC,EACA,CADON,CAAOvB,CAAAA,KAAP,CAAa2B,EAAb,CAAuBC,EAAvB,CAA8B,CAA9B,CACP,CAAAD,EAAA,CAAWC,EAAX,CAAkB,CALpB,CAUA,CAFIC,EAAKvC,CAAAA,MAET,EAFmBuC,EAEnB,GAF4B,IAE5B,GAFkCpC,EAElC,EAF4CgC,CAE5C,EAAAhC,EAAA,EAAUoC,EAGZ,OAAOpC,GAvB6B,CAqDtCsC,QAASA,EAAW,CAACC,CAAD,CAAI,CACtB,MAAS,GAAT,EAAoBA,CAApB,EAAyBA,CAAzB,EAA8B,GAA9B,EACS,GADT,EACoBA,CADpB,EACyBA,CADzB,EAC8B,KAD9B,EAC2CA,CAD3C,GACiD,IADjD,EAC2DA,CAD3D,GACiE,IADjE,EAES,KAFT,EAEoBA,CAFpB,EAEyBA,CAFzB,EAE8B,KAF9B,EAE2CA,CAF3C,GAxL8BC,KAwL9B,EAGS,KAHT,EAGoBD,CAHpB,EAGyBA,CAHzB,EAG8B,OAJR,CAYxBE,QAASA,EAAoB,CAACF,CAAD,CAAI,CAC/B,MAAOD,EAAA,CAAYC,CAAZ,CAAP,EACKA,CADL,GApM8BC,KAoM9B,EAGKD,CAHL,GAjM8BG,EAiM9B,EAIKH,CAJL,GAlM8BI,EAiMC,CAiBjCC,QAASA,EAAW,CAACL,CAAD,CAAIM,CAAJ,CAAUC,EAAV,CAAmB,CACrC,IAAIC,GAAwBN,CAAA,CAAqBF,CAArB,CAA5B,CACIS,GAAYD,EAAZC,EAAqC,EAAcT,CAAd,GAlNXU,EAkNW,EAAcV,CAAd,GArNXW,CAqNW,CACzC,QAEEJ,EAAA,CACEC,EADF,CAEIA,EAFJ;AAIOR,CAJP,GA7M4BY,EA6M5B,EAKOZ,CALP,GAtM4Ba,EAsM5B,EAMOb,CANP,GArM4Bc,EAqM5B,EAOOd,CAPP,GAnM4Be,GAmM5B,EAQOf,CARP,GAjM4BgB,GA+L9B,GAaKhB,CAbL,GAhN8BiB,EAgN9B,EAcK,EAAEX,CAAF,GAvNyBY,EAuNzB,EAAyB,CAACT,EAA1B,CAdL,EAeMP,CAAA,CAAqBI,CAArB,CAfN,EAeoC,EAAcA,CAAd,GAlONI,EAkOM,EAAcJ,CAAd,GArONK,CAqOM,CAfpC,EAe2DX,CAf3D,GAhN8BiB,EAgN9B,EAgBMX,CAhBN,GAzM8BY,EAyM9B,EAgB6BT,EAnBQ,CA8DvCU,QAASA,EAAW,CAAC5B,CAAD,CAAS6B,CAAT,CAAc,CAAA,IAC5BC,GAAQ9B,CAAO+B,CAAAA,UAAP,CAAkBF,CAAlB,CACZ,OAAIC,GAAJ,EAAa,KAAb,EAAuBA,EAAvB,EAAgC,KAAhC,EAA0CD,CAA1C,CAAgD,CAAhD,CAAoD7B,CAAOjC,CAAAA,MAA3D,GACEiE,CACI,CADKhC,CAAO+B,CAAAA,UAAP,CAAkBF,CAAlB,CAAwB,CAAxB,CACL,CAAAG,CAAA,EAAU,KAAV,EAAoBA,CAApB,EAA8B,KAFpC,GAIYF,EAJZ,CAIoB,KAJpB,EAI8B,IAJ9B,CAIsCE,CAJtC,CAI+C,KAJ/C,CAIwD,KAJxD,CAOOF,EATyB,CA+BlCG,QAASA,EAAiB,CAACjC,CAAD,CAASkC,CAAT,CAAyBC,EAAzB,CAAyCnD,EAAzC,CACxBoD,EADwB,CACLhD,EADK,CACQG,EADR,CACqByB,EADrB,CAC8B,CAGtD,IACIqB,GAAW,IADf,CAEIC,EAAe,CAAA,CAFnB,CAGIC,EAAkB,CAAA,CAHtB,CAIIC,EAAmBxD,EAAnBwD,GAAiC,CAAC,CAJtC,CAKIC,EAAoB,CAAC,CALzB,CAM6B,EAAAb,CAAA,CAAY5B,CAAZ,CAAoB,CAApB,CAAjB,IAAA,CAAA,CA5ELQ,CAAA,CAAYC,CAAZ,CA4EK,EA5EaA,CA4Eb,GA3TkBC,KA2TlB,EA3EP,EAAcD,CAAd,GA5OyBU,EA4OzB,EAAcV,CAAd,GA/OyBW,CA+OzB,CA2EO,EAxEPX,CAwEO,GA9SkBiC,EA8SlB,EAvEPjC,CAuEO,GA1SkBkC,EA0SlB,EAtEPlC,CAsEO,GA7SkBkB,EA6SlB,EArEPlB,CAqEO,GA/SkBY,EA+SlB,EApEPZ,CAoEO,GAxSkBa,EAwSlB,EAnEPb,CAmEO,GAvSkBc,EAuSlB,EAlEPd,CAkEO,GArSkBe,GAqSlB,EAjEPf,CAiEO,GAnSkBgB,GAmSlB,EA/DPhB,CA+DO,GApTkBiB,EAoTlB,EA9DPjB,CA8DO,GAlTkBmC,EAkTlB,EA7DPnC,CA6DO,GAhTkBoC,EAgTlB,EA5DPpC,CA4DO,GAtTkBqC,EAsTlB,EA3DPrC,CA2DO,GApSkBsC,GAoSlB,EA1DPtC,CA0DO,GA5SkBuC,EA4SlB;AAzDPvC,CAyDO,GA3SkBwC,EA2SlB,EAxDPxC,CAwDO,GAjTkByC,EAiTlB,EAvDPzC,CAuDO,GArTkB0C,EAqTlB,EArDP1C,CAqDO,GAnTkB2C,EAmTlB,EApDP3C,CAoDO,GAzSkB4C,EAySlB,EAnDP5C,CAmDO,GAtSkB6C,EAsSlB,CACD,CA9CX,CA8CW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CA9CX,CAAA,CAAA,CAAO,EAAc7C,CAAd,GA1QuBU,EA0QvB,EAAcV,CAAd,GA7QuBW,CA6QvB,CAAP,EAA2BX,CAA3B,GAhQ8BkB,EAgT9B,IAAIO,CAAJ,EAAsB3C,EAAtB,CAGE,IAAKgE,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBvD,CAAOjC,CAAAA,MAAvB,CAA+ByF,EAAA,EAAQ,KAAR,CAAkBD,CAAlB,EAAuB,CAAvB,CAA2BA,CAAA,EAA1D,CAA+D,CAC7D,IAAAC,GAAO5B,CAAA,CAAY5B,CAAZ,CAAoBuD,CAApB,CACP,IAAI,CAAC/C,CAAA,CAAYgD,EAAZ,CAAL,CACE,MA5BYC,EA8BdC,EAAA,CAAQA,CAAR,EAAiB5C,CAAA,CAAY0C,EAAZ,CAAkBnB,EAAlB,CAA4BrB,EAA5B,CACjBqB,GAAA,CAAWmB,EANkD,CAHjE,IAWO,CAEL,IAAKD,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBvD,CAAOjC,CAAAA,MAAvB,CAA+ByF,EAAA,EAAQ,KAAR,CAAkBD,CAAlB,EAAuB,CAAvB,CAA2BA,CAAA,EAA1D,CAA+D,CAC7DC,EAAA,CAAO5B,CAAA,CAAY5B,CAAZ,CAAoBuD,CAApB,CACP,IAAIC,EAAJ,GA3U0B3C,EA2U1B,CACEyB,CAEA,CAFe,CAAA,CAEf,CAAIE,CAAJ,GACED,CAIA,CAJkBA,CAIlB,EAFGgB,CAEH,CAFOd,CAEP,CAF2B,CAE3B,CAF+BzD,EAE/B,EADGgB,CAAA,CAAOyC,CAAP,CAA2B,CAA3B,CACH,GADqC,GACrC,CAAAA,CAAA,CAAoBc,CALtB,CAHF,KAUO,IAAI,CAAC/C,CAAA,CAAYgD,EAAZ,CAAL,CACL,MAhDYC,EAkDdC,EAAA,CAAQA,CAAR,EAAiB5C,CAAA,CAAY0C,EAAZ,CAAkBnB,EAAlB,CAA4BrB,EAA5B,CACjBqB,GAAA,CAAWmB,EAhBkD,CAmB/DjB,CAAA,CAAkBA,CAAlB,EAAsCC,CAAtC,EACGe,CADH,CACOd,CADP,CAC2B,CAD3B,CAC+BzD,EAD/B,EAEGgB,CAAA,CAAOyC,CAAP,CAA2B,CAA3B,CAFH,GAEqC,GAvBhC,CA4BP,MAAKH,EAAL,EAAsBC,CAAtB,CASIJ,EAAJ,CAAqB,CAArB,EA9EqBwB,OACCC,CAAAA,IAAf,CA6EuC5D,CA7EvC,CA6EP,CAtEkByD,CAsElB,CAKKlE,EAAL,CAGOH,EAAA,GAjRiBC,CAiRjB,CA9EWoE,CA8EX,CAjFWI,CA8ElB,CACStB,CAAA,CA7ESuB,CA6ET,CA9ESC,CA+DlB,CAGML,CAAAA,CAAJ,EAAcnE,EAAd,EAA8B6C,EAAA,CAAkBpC,CAAlB,CAA9B,CAGOZ,EAAA,GAtQeC,CAsQf,CAnESoE,CAmET,CAtESI,CAmEhB,CApEgBG,CAcoC,CA6ExDC,QAASA,EAAW,CAACC,CAAD,CAAQlE,CAAR,CAAgBmE,EAAhB,CAAuBC,EAAvB,CAA8BpD,EAA9B,CAAuC,CACzDkD,CAAMG,CAAAA,IAAN,CAAc,QAAS,EAAG,CACxB,GAAIrE,CAAOjC,CAAAA,MAAX;AAAsB,CAAtB,CACE,MAAOmG,EAAM9E,CAAAA,WAAN,GA7RaC,CA6Rb,CAA4C,IAA5C,CAAmD,IAE5D,IAAI,CAAC6E,CAAMhF,CAAAA,YAAX,GACMoF,EAA2B/D,CAAAA,OAA3B,CAAmCP,CAAnC,CADN,GACqD,CAAC,CADtD,EAC2DuE,EAAyBX,CAAAA,IAAzB,CAA8B5D,CAA9B,CAD3D,EAEI,MAAOkE,EAAM9E,CAAAA,WAAN,GAjSWC,CAiSX,CAA6C,GAA7C,CAAmDW,CAAnD,CAA4D,GAA5D,CAAoE,GAApE,CAA0EA,CAA1E,CAAmF,GAI9F,KAAIzC,GAAS2G,CAAM3G,CAAAA,MAAfA,CAAwBC,IAAKC,CAAAA,GAAL,CAAS,CAAT,CAAY0G,EAAZ,CAA5B,CAQInF,GAAYkF,CAAMlF,CAAAA,SAAN,GAAoB,CAAC,CAArB,CACZ,CAAC,CADW,CACPxB,IAAKC,CAAAA,GAAL,CAASD,IAAKgH,CAAAA,GAAL,CAASN,CAAMlF,CAAAA,SAAf,CAA0B,EAA1B,CAAT,CAAwCkF,CAAMlF,CAAAA,SAA9C,CAA0DzB,EAA1D,CAUT,QAAQ0E,CAAA,CAAkBjC,CAAlB,CAPaoE,EAOb,EALFF,CAAMtG,CAAAA,SAKJ,CALgB,CAAC,CAKjB,EALsBuG,EAKtB,EAL+BD,CAAMtG,CAAAA,SAKrC,CAA0CsG,CAAM3G,CAAAA,MAAhD,CAAwDyB,EAAxD,CAJRyF,QAAsB,CAACzE,EAAD,CAAS,CAzPQ,CAAA,CAAA,CAAA,IAC9BjC,EAEN,KAAAM,EAAQ,CAAb,KAAgBN,EAAhB,CAuPiCmG,CAvPFzE,CAAAA,aAAc1B,CAAAA,MAA7C,CAAqDM,CAArD,CAA6DN,EAA7D,CAAqEM,CAArE,EAA8E,CAA9E,CAAiF,CAC/E,IAAAL,EAsP+BkG,CAtPlBzE,CAAAA,aAAN,CAAoBpB,CAApB,CAEP,IAAIL,CAAK0G,CAAAA,OAAL,CAoPkC1E,EApPlC,CAAJ,CAAuB,CACrB,EAAA,CAAO,CAAA,CAAP,OAAA,CADqB,CAHwD,CAQjF,EAAA,CAAO,CAAA,CAXkC,CA0PrC,MAAO,GADsB,CAIvB,CACSkE,CAAM9E,CAAAA,WADf,CAC4B8E,CAAM3E,CAAAA,WADlC,EACiD,CAAC6E,EADlD,CACyDpD,EADzD,CAAR,CAAA,CAGE,KA5HcgD,CA4Hd,CACE,MAAOhE,EACT,MA7Hc6D,CA6Hd,CACE,MAAO,GAAP;AAAa7D,CAAO2E,CAAAA,OAAP,CAAe,IAAf,CAAqB,IAArB,CAAb,CAA0C,GAC5C,MA9HcZ,CA8Hd,CACE,MAAO,GAAP,CAAaa,CAAA,CAAY5E,CAAZ,CAAoBkE,CAAM3G,CAAAA,MAA1B,CAAb,CACIsH,CAAA,CAAkB9E,CAAA,CAAaC,CAAb,CAAqBzC,EAArB,CAAlB,CACN,MAhIcuG,CAgId,CACE,MAAO,MAAP,CAAac,CAAA,CAAY5E,CAAZ,CAAoBkE,CAAM3G,CAAAA,MAA1B,CAAb,CACIsH,CAAA,CAAkB9E,CAAA,CAAa+E,EAAA,CAAW9E,CAAX,CAAmBhB,EAAnB,CAAb,CAA4CzB,EAA5C,CAAlB,CACN,MAlIckG,CAkId,CACE,MAAO,GAAP,CAAasB,EAAA,CAAa/E,CAAb,CAAqBhB,EAArB,CAAb,CAA+C,GACjD,SACE,KAAM,KAAIgG,EAAJ,CAAkB,wCAAlB,CAAN,CAhBJ,CA7BwB,CAAZ,EAD2C,CAoD3DJ,QAASA,EAAW,CAAC5E,CAAD,CAASmC,CAAT,CAAyB,CACvC8C,CAAAA,CApJiBtB,OACCC,CAAAA,IAAf,CAmJmC5D,CAnJnC,CAmJe,CAA8BxB,MAAA,CAAO2D,CAAP,CAA9B,CAAuD,EAG7E,KAAI+C,GAAgBlF,CAAA,CAAOA,CAAOjC,CAAAA,MAAd,CAAuB,CAAvB,CAAhBmH,GAA8C,IAIlD,OAAOD,EAAP,EAHWC,CAAAA,EACCC,EADQnF,CAAA,CAAOA,CAAOjC,CAAAA,MAAd,CAAuB,CAAvB,CACRoH,GADsC,IACtCA,EAD8CnF,CAC9CmF,GADyD,IACzDA,CAAcD,EAAA,CAAO,EAAP,CAAY,GAA1BC,CAAO,GAEnB,EAAiC,IARU,CAY7CN,QAASA,EAAiB,CAAC7E,CAAD,CAAS,CACjC,MAAOA,EAAA,CAAOA,CAAOjC,CAAAA,MAAd,CAAuB,CAAvB,CAAA,GAA8B,IAA9B,CAAqCiC,CAAOvB,CAAAA,KAAP,CAAa,CAAb,CAAgB,CAAC,CAAjB,CAArC,CAA2DuB,CADjC,CAMnC8E,QAASA,GAAU,CAAC9E,CAAD,CAASoF,CAAT,CAAgB,CAKjC,IAAIC,GAAS,gBAIPC,KAAAA,GAAStF,CAAOO,CAAAA,OAAP,CAAe,IAAf,CACb+E,GAAA,CAASA,EAAA,GAAW,CAAC,CAAZ,CAAgBA,EAAhB,CAAyBtF,CAAOjC,CAAAA,MACzCsH;EAAOE,CAAAA,SAAP,CAAmBD,EACnB,GAAA,CAAOE,EAAA,CAASxF,CAAOvB,CAAAA,KAAP,CAAa,CAAb,CAAgB6G,EAAhB,CAAT,CAAkCF,CAAlC,CAQT,KALA,IAAIK,GAAmBzF,CAAA,CAAO,CAAP,CAAnByF,GAAiC,IAAjCA,EAAyCzF,CAAA,CAAO,CAAP,CAAzCyF,GAAuD,GAA3D,CACIC,EAIJ,CAAQC,EAAR,CAAgBN,EAAOO,CAAAA,IAAP,CAAY5F,CAAZ,CAAhB,CAAA,CAAsC,CAAA,IAChC6F,GAASF,EAAA,CAAM,CAAN,CADuB,CACbrF,GAAOqF,EAAA,CAAM,CAAN,CAC9BD,GAAA,CAAgBpF,EAAA,CAAK,CAAL,CAAhB,GAA4B,GAC5BpC,GAAA,EAAU2H,EAAV,EACMJ,EAAD,EAAsBC,EAAtB,EAAsCpF,EAAtC,GAA+C,EAA/C,CACQ,EADR,CACC,IAFN,EAGIkF,EAAA,CAASlF,EAAT,CAAe8E,CAAf,CACJK,GAAA,CAAmBC,EAPiB,CAUtC,MAAOxH,GA9B0B,CAqCnCsH,QAASA,GAAQ,CAAClF,CAAD,CAAO8E,CAAP,CAAc,CAC7B,GAAI9E,CAAJ,GAAa,EAAb,EAAmBA,CAAA,CAAK,CAAL,CAAnB,GAA+B,GAA/B,CAAoC,MAAOA,EAG3C,KAAIwF,GAAU,QAAd,CACIH,EADJ,CAGII,GAAQ,CAAQC,KAAAA,GAAO,CAO3B,KANA,IAAI9H,GAAS,EAMb,CAAQyH,EAAR,CAAgBG,EAAQF,CAAAA,IAAR,CAAatF,CAAb,CAAhB,CAAA,CACED,EAQA,CAROsF,EAAMtH,CAAAA,KAQb,CANIgC,EAMJ,CANW0F,EAMX,CANmBX,CAMnB,GALEa,EAGA,CAHOD,EAAD,CAAQD,EAAR,CAAiBC,EAAjB,CAAwB3F,EAG9B,CAFAnC,EAEA,EAFU,IAEV,CAFiBoC,CAAK7B,CAAAA,KAAL,CAAWsH,EAAX,CAAkBE,EAAlB,CAEjB,CAAAF,EAAA,CAAQE,EAAR,CAAc,CAEhB,EAAAD,EAAA,CAAO3F,EAKTnC,GAAA,EAAU,IAGRA,GAAA,CADEoC,CAAKvC,CAAAA,MAAT,CAAkBgI,EAAlB,CAA0BX,CAA1B,EAAmCY,EAAnC,CAA0CD,EAA1C,CACE7H,EADF,EACYoC,CAAK7B,CAAAA,KAAL,CAAWsH,EAAX,CAAkBC,EAAlB,CADZ,CACsC,IADtC,CAC6C1F,CAAK7B,CAAAA,KAAL,CAAWuH,EAAX,CAAkB,CAAlB,CAD7C,EAGE9H,EAHF,CAGYoC,CAAK7B,CAAAA,KAAL,CAAWsH,EAAX,CAGZ,OAAO7H,GAAOO,CAAAA,KAAP,CAAa,CAAb,CApCsB,CAwC/BsG,QAASA,GAAY,CAAC/E,CAAD,CAAS,CAK5B,IAJA,IAAI9B;AAAS,EAAb,CACIsF,EADJ,CAEI0C,EAFJ,CAIS3C,GAAI,CAAb,CAAgBA,EAAhB,CAAoBvD,CAAOjC,CAAAA,MAA3B,CAAmCyF,EAAA,EAAQ,KAAR,CAAkBD,EAAlB,EAAuB,CAAvB,CAA2BA,EAAA,EAA9D,CAIE,GAHAC,EAGI,CAHG5B,CAAA,CAAY5B,CAAZ,CAAoBuD,EAApB,CAGH,CAFJ2C,EAEI,CAFQC,EAAA,CAAiB3C,EAAjB,CAER,CAAA,CAAC0C,EAAD,EAAc1F,CAAA,CAAYgD,EAAZ,CAAlB,CACEtF,CACA,EADU8B,CAAA,CAAOuD,EAAP,CACV,CAAIC,EAAJ,EAAY,KAAZ,GAAqBtF,CAArB,EAA+B8B,CAAA,CAAOuD,EAAP,CAAW,CAAX,CAA/B,CAFF,KAGO,CACK,GAAA2C,CAAAA,EAAA,CAAA,CAAa,IAAA,GAAA,EA9c3BlG,GAAA,CAASoG,EAAUC,CAAAA,QAAV,CAAmB,EAAnB,CAAuBC,CAAAA,WAAvB,EAET,IAAIF,EAAJ,EAAiB,GAAjB,CAAuB,CACrB,IAAAG,GAAS,GACTxI,GAAA,CAAS,CAFY,CAAvB,IAGO,IAAIqI,EAAJ,EAAiB,KAAjB,CACLG,EACA,CADS,GACT,CAAAxI,EAAA,CAAS,CAFJ,KAGA,IAAIqI,EAAJ,EAAiB,UAAjB,CACLG,EACA,CADS,GACT,CAAAxI,EAAA,CAAS,CAFJ,KAIL,MAAM,KAAIiH,EAAJ,CAAkB,+DAAlB,CAAN,CAGF,EAAA,CAAO,IAAP,CAAcuB,EAAd,CAAuB1I,EAAOsC,CAAAA,MAAP,CAAc,GAAd,CAAmBpC,EAAnB,CAA4BiC,EAAOjC,CAAAA,MAAnC,CAAvB,CAAoEiC,EA+btD,CAAV9B,CAAA,EAAU,EADL,CAKT,MAAOA,EAjBqB,CAgD9BsI,QAASA,GAAkB,CAACtC,CAAD,CAAQC,CAAR,CAAesC,EAAf,CAAuBC,EAAvB,CAAgC,CAAA,IACrDC,GAAU,EAD2C,CAErDC,GAAU1C,CAAM5F,CAAAA,GAFqC,CAIrDP,EAGC,KAAAM,GAAQ,CAAb,KAAgBN,EAAhB,CAAyB0I,EAAO1I,CAAAA,MAAhC,CAAwCM,EAAxC,CAAgDN,EAAhD,CAAwDM,EAAxD,EAAiE,CAAjE,CAAoE,CAClE,IAAAwI,GAAQJ,EAAA,CAAOpI,EAAP,CAEJ6F;CAAM1E,CAAAA,QAAV,GACEqH,EADF,CACU3C,CAAM1E,CAAAA,QAASZ,CAAAA,IAAf,CAAoB6H,EAApB,CAA4BjI,MAAA,CAAOH,EAAP,CAA5B,CAA2CwI,EAA3C,CADV,CAKA,IAAIC,EAAA,CAAU5C,CAAV,CAAiBC,CAAjB,CAAyB,CAAzB,CAA4B0C,EAA5B,CAAmC,CAAA,CAAnC,CAAyC,CAAA,CAAzC,CAA+C,CAAA,CAA/C,CAAsD,CAAA,CAAtD,CAAJ,EACK,MAAOA,GADZ,GACsB,WADtB,EAEKC,EAAA,CAAU5C,CAAV,CAAiBC,CAAjB,CAAyB,CAAzB,CAA4B,IAA5B,CAAkC,CAAA,CAAlC,CAAwC,CAAA,CAAxC,CAA8C,CAAA,CAA9C,CAAqD,CAAA,CAArD,CAFL,CAIOuC,EAUL,EAVgBC,EAUhB,GAV4B,EAU5B,GATEA,EASF,EAlcG,IAkcH,CAlcU9I,EAAOsC,CAAAA,MAAP,CAAc,GAAd,CAyboB+D,CAzbK3G,CAAAA,MAAzB,CAyb2B4G,CAzb3B,CAkcV,EALEwC,EAKF,CANIzC,CAAMG,CAAAA,IAAV,EAvlB0BxD,EAulB1B,GAAqCqD,CAAMG,CAAAA,IAAKtC,CAAAA,UAAX,CAAsB,CAAtB,CAArC,CACE4E,EADF,CACa,GADb,CAGEA,EAHF,CAGa,IAGb,CAAAA,EAAA,EAAWzC,CAAMG,CAAAA,IAtB+C,CA0BpEH,CAAM5F,CAAAA,GAAN,CAAYsI,EACZ1C,EAAMG,CAAAA,IAAN,CAAasC,EAAb,EAAwB,IAlCiC,CAiK3DI,QAASA,GAAU,CAAC7C,CAAD,CAAQuC,CAAR,CAAgBO,EAAhB,CAA0B,CAAA,IACbjJ,EAE9B,KAAAkJ,GAAWD,EAAA,CAAW9C,CAAMvE,CAAAA,aAAjB,CAAiCuE,CAAMzE,CAAAA,aAE7C,KAAApB,GAAQ,CAAb,KAAgBN,EAAhB,CAAyBkJ,EAASlJ,CAAAA,MAAlC,CAA0CM,EAA1C,CAAkDN,EAAlD,CAA0DM,EAA1D,EAAmE,CAAnE,CAAsE,CACpE,IAAAL,GAAOiJ,EAAA,CAAS5I,EAAT,CAEP,KAAKL,EAAKkJ,CAAAA,UAAV,EAAyBlJ,EAAKmJ,CAAAA,SAA9B,IACK,CAACnJ,EAAKkJ,CAAAA,UADX,EAC2B,MAAOT,EADlC,GAC6C,QAD7C,EAC2DA,CAD3D,WAC6EzI,GAAKkJ,CAAAA,UADlF,IAEK,CAAClJ,EAAKmJ,CAAAA,SAFX;AAEyBnJ,EAAKmJ,CAAAA,SAAL,CAAeV,CAAf,CAFzB,EAEkD,CAI5CvC,CAAM5F,CAAAA,GAAN,CAFA0I,EAAJ,CACMhJ,EAAKoJ,CAAAA,KAAT,EAAkBpJ,EAAKqJ,CAAAA,aAAvB,CACcrJ,EAAKqJ,CAAAA,aAAL,CAAmBZ,CAAnB,CADd,CAGczI,EAAKM,CAAAA,GAJrB,CAOc,GAGd,IAAIN,EAAKsJ,CAAAA,SAAT,CAAoB,CAClB/I,EAAA,CAAQ2F,CAAMpF,CAAAA,QAAN,CAAed,EAAKM,CAAAA,GAApB,CAAR,EAAoCN,EAAKuJ,CAAAA,YAEzC,IAAIC,CAAU5I,CAAAA,IAAV,CAAeZ,EAAKsJ,CAAAA,SAApB,CAAJ,GAAuC,mBAAvC,CACEX,CAAA,CAAU3I,EAAKsJ,CAAAA,SAAL,CAAeb,CAAf,CAAuBlI,EAAvB,CADZ,KAEO,IAAII,EAAgBC,CAAAA,IAAhB,CAAqBZ,EAAKsJ,CAAAA,SAA1B,CAAqC/I,EAArC,CAAJ,CACLoI,CAAA,CAAU3I,EAAKsJ,CAAAA,SAAL,CAAe/I,EAAf,CAAA,CAAsBkI,CAAtB,CAA8BlI,EAA9B,CADL,KAGL,MAAM,KAAIyG,EAAJ,CAAkB,OAAlB,CAAyBhH,EAAKM,CAAAA,GAA9B,CAAoC,iCAApC,CAAqEC,EAArE,CAA6E,SAA7E,CAAN,CAGF2F,CAAMG,CAAAA,IAAN,CAAasC,CAXK,CAcpB,MAAO,CAAA,CA1ByC,CALkB,CAmCtE,MAAO,CAAA,CAxCoC,CA8C7CG,QAASA,GAAS,CAAC5C,CAAD,CAAQC,CAAR,CAAesC,EAAf,CAAuBgB,EAAvB,CAA8Bf,EAA9B,CAAuCtC,EAAvC,CAA8CsD,EAA9C,CAA0D,CAC1ExD,CAAM5F,CAAAA,GAAN,CAAY,IACZ4F,EAAMG,CAAAA,IAAN,CAAaoC,EAERM,GAAA,CAAW7C,CAAX,CAAkBuC,EAAlB,CAA0B,CAAA,CAA1B,CAAL,EACEM,EAAA,CAAW7C,CAAX,CAAkBuC,EAAlB,CAA0B,CAAA,CAA1B,CAGF,KAAIzI,GAAOwJ,CAAU5I,CAAAA,IAAV,CAAesF,CAAMG,CAAAA,IAArB,CAAX,CACIrD,GAAUyG,EAGVA,GAAJ,GACEA,EADF,CACWvD,CAAMtG,CAAAA,SADjB;AAC6B,CAD7B,EACkCsG,CAAMtG,CAAAA,SADxC,CACoDuG,CADpD,CAZ0E,KAgBtEwD,EAAgB3J,EAAhB2J,GAAyB,iBAAzBA,EAA8C3J,EAA9C2J,GAAuD,gBAI3D,IAAIA,CAAJ,CAAmB,CACjB,IAAAC,EAAiB1D,CAAMrE,CAAAA,UAAWU,CAAAA,OAAjB,CAAyBkG,EAAzB,CACjB,KAAAoB,EAAYD,CAAZC,GAA+B,CAAC,CAFf,CAKnB,GAAK3D,CAAM5F,CAAAA,GAAX,GAAmB,IAAnB,EAA2B4F,CAAM5F,CAAAA,GAAjC,GAAyC,GAAzC,EAAiDuJ,CAAjD,EAA+D3D,CAAM3G,CAAAA,MAArE,GAAgF,CAAhF,EAAqF4G,CAArF,CAA6F,CAA7F,CACEuC,EAAA,CAAU,CAAA,CAGZ,IAAImB,CAAJ,EAAiB3D,CAAMpE,CAAAA,cAAN,CAAqB8H,CAArB,CAAjB,CACE1D,CAAMG,CAAAA,IAAN,CAAa,OAAb,CAAuBuD,CADzB,KAEO,CACDD,CAAJ,EAAqBE,CAArB,EAAkC,CAAC3D,CAAMpE,CAAAA,cAAN,CAAqB8H,CAArB,CAAnC,GACE1D,CAAMpE,CAAAA,cAAN,CAAqB8H,CAArB,CADF,CACyC,CAAA,CADzC,CAGA,IAAI5J,EAAJ,GAAa,iBAAb,CACE,GAAIyJ,EAAJ,EAAcrJ,MAAOD,CAAAA,IAAP,CAAY+F,CAAMG,CAAAA,IAAlB,CAAwBtG,CAAAA,MAAtC,GAAiD,CAAjD,CAAqD,CACbsG,EAAAA,CAANH,CAAMG,CAAAA,IAhKxCsC,GAAAA,CAAgB,EAChBC,GAAAA,CA+JoB1C,CA/JE5F,CAAAA,GACtBwJ,GAAAA,CAAgB1J,MAAOD,CAAAA,IAAP,CAAYsI,EAAZ,CASpB,IAqJwBvC,CArJdnF,CAAAA,QAAV,GAAuB,CAAA,CAAvB,CAEE+I,EAAcC,CAAAA,IAAd,EAFF,KAGO,IAAI,MAkJa7D,EAlJAnF,CAAAA,QAAjB,GAA8B,UAA9B,CAEL+I,EAAcC,CAAAA,IAAd,CAgJsB7D,CAhJGnF,CAAAA,QAAzB,CAFK,KAGA,IA+IiBmF,CA/IPnF,CAAAA,QAAV,CAEL,KAAM,KAAIiG,EAAJ,CAAkB,0CAAlB,CAAN;AAGG3G,EAAA,CAAQ,CAAb,KAAgBN,EAAhB,CAAyB+J,EAAc/J,CAAAA,MAAvC,CAA+CM,EAA/C,CAAuDN,EAAvD,CAA+DM,EAA/D,EAAwE,CAAxE,CAA2E,CACzE,IAAA2J,EAAa,EAERtB,GAAL,EAAgBC,EAAhB,GAA4B,EAA5B,GACEqB,CADF,EAlhBK,IAkhBL,CAlhBYnK,EAAOsC,CAAAA,MAAP,CAAc,GAAd,CAypBU+D,CAzpBe3G,CAAAA,MAAzB,CAypBiB4G,CAzpBjB,CAkhBZ,CAIA,KAAA8D,EAAYH,EAAA,CAAczJ,EAAd,CACZ6J,EAAA,CAAczB,EAAA,CAAOwB,CAAP,CAkIQ/D,EAhIZ1E,CAAAA,QAAV,GACE0I,CADF,CAgIsBhE,CA/HA1E,CAAAA,QAASZ,CAAAA,IAAf,CAAoB6H,EAApB,CAA4BwB,CAA5B,CAAuCC,CAAvC,CADhB,CAIKpB,GAAA,CA4HiB5C,CA5HjB,CA4HwBC,CA5HxB,CAAyB,CAAzB,CAA4B8D,CAA5B,CAAuC,CAAA,CAAvC,CAA6C,CAAA,CAA7C,CAAmD,CAAA,CAAnD,CAAL,GAqBA,CAjBAE,CAiBA,CAuGsBjE,CAxHA5F,CAAAA,GAiBtB,GAjB8B,IAiB9B,EAuGsB4F,CAxHsB5F,CAAAA,GAiB5C,GAjBoD,GAiBpD,EAuGsB4F,CAvHAG,CAAAA,IAgBtB,EAuGsBH,CAvHcG,CAAAA,IAAKtG,CAAAA,MAgBzC,CAhBkD,IAgBlD,IAZIiK,CAYJ,CAuGsB9D,CApHVG,CAAAA,IAAV,EAhsB0BxD,EAgsB1B,GAoHoBqD,CApHuBG,CAAAA,IAAKtC,CAAAA,UAAX,CAAsB,CAAtB,CAArC,CACEiG,CADF,CACgB,GADhB,CAGEA,CAHF,CAGgB,IAUlB,EANAA,CAMA,EAuGsB9D,CA7GFG,CAAAA,IAMpB,CAJI8D,CAIJ,GAHEH,CAGF,EAljBK,IAkjBL,CAljBYnK,EAAOsC,CAAAA,MAAP,CAAc,GAAd,CAypBU+D,CAzpBe3G,CAAAA,MAAzB,CAypBiB4G,CAzpBjB,CAkjBZ,EAAK2C,EAAA,CAuGiB5C,CAvGjB,CAuGwBC,CAvGxB,CAAyB,CAAzB,CAA4B+D,CAA5B,CAAyC,CAAA,CAAzC,CAA+CC,CAA/C,CAAL,GAKEH,CAQF,CA0FsB9D,CAnGZG,CAAAA,IAAV,EAjtB4BxD,EAitB5B,GAmGsBqD,CAnGqBG,CAAAA,IAAKtC,CAAAA,UAAX,CAAsB,CAAtB,CAArC,CACEiG,CADF,CACgB,GADhB,CAGEA,CAHF,CAGgB,IAMhB,CAHAA,CAGA,EA0FsB9D,CA7FFG,CAAAA,IAGpB,CAAAsC,EAAA,EAAWqB,CAbX,CArBA,CAdyE,CA0InD9D,CAvFlB5F,CAAAA,GAAN,CAAYsI,EAuFY1C,EAtFlBG,CAAAA,IAAN,CAAasC,EAAb,EAAwB,IAuFdkB,EAAJ,GACE3D,CAAMG,CAAAA,IADR,CACe,UADf,CACyBuD,CADzB,CAC0C1D,CAAMG,CAAAA,IADhD,CAFmD,CAArD,IAKO,CACgCA,EAAAA,CAANH,CAAMG,CAAAA,IAnNvCsC,GAAAA,CAAgB,EAChBC,GAAAA;AAkNmB1C,CAlNG5F,CAAAA,GACtBwJ,GAAAA,CAAgB1J,MAAOD,CAAAA,IAAP,CAAYsI,EAAZ,CAOfpI,GAAA,CAAQ,CAAb,KAAgBN,EAAhB,CAAyB+J,EAAc/J,CAAAA,MAAvC,CAA+CM,EAA/C,CAAuDN,EAAvD,CAA+DM,EAA/D,EAAwE,CAAxE,CAEE2J,CAYA,CAZa,EAYb,CAXIrB,EAWJ,GAXgB,EAWhB,GAXoBqB,CAWpB,EAXkC,IAWlC,EA4LqB9D,CArMX/E,CAAAA,YASV,GATwB6I,CASxB,EATsC,GAStC,EAPAC,EAOA,CAPYH,EAAA,CAAczJ,EAAd,CAOZ,CANA6J,CAMA,CANczB,EAAA,CAAOwB,EAAP,CAMd,CA4LqB/D,CAhMX1E,CAAAA,QAIV,GAHE0I,CAGF,CA4LqBhE,CA/LC1E,CAAAA,QAASZ,CAAAA,IAAf,CAAoB6H,EAApB,CAA4BwB,EAA5B,CAAuCC,CAAvC,CAGhB,EAAKpB,EAAA,CA4LgB5C,CA5LhB,CA4LuBC,CA5LvB,CAAwB8D,EAAxB,CAAmC,CAAA,CAAnC,CAA0C,CAAA,CAA1C,CAAL,GA4LqB/D,CAxLXG,CAAAA,IAAKtG,CAAAA,MAIf,CAJwB,IAIxB,GAJ8BiK,CAI9B,EAJ4C,IAI5C,EAFAA,CAEA,EAoLqB9D,CAtLDG,CAAAA,IAEpB,EAoLqBH,CAtLa/E,CAAAA,YAAN,CAAqB,GAArB,CAA2B,EAEvD,EAF6D,GAE7D,EAoLqB+E,CAtLqD/E,CAAAA,YAAN,CAAqB,EAArB,CAA0B,GAE9F,EAAK2H,EAAA,CAoLgB5C,CApLhB,CAoLuBC,CApLvB,CAAwB+D,CAAxB,CAAqC,CAAA,CAArC,CAA4C,CAAA,CAA5C,CAAL,GAIAF,CAGA,EA6KqB9D,CAhLDG,CAAAA,IAGpB,CAAAsC,EAAA,EAAWqB,CAPX,CARA,CA4LqB9D,EA1KjB5F,CAAAA,GAAN,CAAYsI,EA0KW1C,EAzKjBG,CAAAA,IAAN,CAAa,GAAb,CAAmBsC,EAAnB,CAA6B,GA0KnBkB,EAAJ,GACE3D,CAAMG,CAAAA,IADR,CACe,UADf,CACyBuD,CADzB,CAC0C,GAD1C,CACgD1D,CAAMG,CAAAA,IADtD,CAFK,CANT,IAYO,IAAIrG,EAAJ,GAAa,gBAAb,CACL,GAAIyJ,EAAJ,EAAcvD,CAAMG,CAAAA,IAAKtG,CAAAA,MAAzB,GAAoC,CAApC,CACMmG,CAAMxG,CAAAA,aAAV,EAA2B,CAACgK,EAA5B,EAA0CvD,CAA1C,CAAkD,CAAlD,CACEqC,EAAA,CAAmBtC,CAAnB,CAA0BC,CAA1B,CAAkC,CAAlC,CAAqCD,CAAMG,CAAAA,IAA3C,CAAiDqC,EAAjD,CADF,CAGEF,EAAA,CAAmBtC,CAAnB,CAA0BC,CAA1B,CAAiCD,CAAMG,CAAAA,IAAvC,CAA6CqC,EAA7C,CAEF,CAAImB,CAAJ,GACE3D,CAAMG,CAAAA,IADR;AACe,UADf,CACyBuD,CADzB,CAC0C1D,CAAMG,CAAAA,IADhD,CANF,KASO,CACiCA,EAAAA,CAANH,CAAMG,CAAAA,IApSxCsC,GAAAA,CAAU,EACVC,GAAAA,CAmSoB1C,CAnSJ5F,CAAAA,GAKfD,GAAA,CAAQ,CAAb,KAAgBN,EAAhB,CAAyB0I,EAAO1I,CAAAA,MAAhC,CAAwCM,EAAxC,CAAgDN,EAAhD,CAAwDM,EAAxD,EAAiE,CAAjE,CAQE,GAPAwI,EAOI,CAPIJ,EAAA,CAAOpI,EAAP,CAOJ,CAsRkB6F,CA3RZ1E,CAAAA,QAKN,GAJFqH,EAIE,CAsRkB3C,CA1RN1E,CAAAA,QAASZ,CAAAA,IAAf,CAAoB6H,EAApB,CAA4BjI,MAAA,CAAOH,EAAP,CAA5B,CAA2CwI,EAA3C,CAIN,EAAAC,EAAA,CAsRkB5C,CAtRlB,CAsRyBC,CAtRzB,CAAwB0C,EAAxB,CAA+B,CAAA,CAA/B,CAAsC,CAAA,CAAtC,CAAA,EACC,MAAOA,GADR,GACkB,WADlB,EAECC,EAAA,CAoRiB5C,CApRjB,CAoRwBC,CApRxB,CAAwB,IAAxB,CAA8B,CAAA,CAA9B,CAAqC,CAAA,CAArC,CAFL,CAIMwC,EACJ,GADgB,EAChB,GADoBA,EACpB,EAD+B,GAC/B,EAiRoBzC,CAlRyB/E,CAAAA,YAAP,CAA4B,EAA5B,CAAsB,GAC5D,GAAAwH,EAAA,EAiRoBzC,CAjRHG,CAAAA,IAiRGH,EA7QlB5F,CAAAA,GAAN,CAAYsI,EA6QY1C,EA5QlBG,CAAAA,IAAN,CAAa,GAAb,CAAmBsC,EAAnB,CAA6B,GA6QnBkB,EAAJ,GACE3D,CAAMG,CAAAA,IADR,CACe,UADf,CACyBuD,CADzB,CAC0C,GAD1C,CACgD1D,CAAMG,CAAAA,IADtD,CAFK,CAVF,IAgBA,IAAIrG,EAAJ,GAAa,iBAAb,CACDkG,CAAM5F,CAAAA,GAAV,GAAkB,GAAlB,EACE2F,CAAA,CAAYC,CAAZ,CAAmBA,CAAMG,CAAAA,IAAzB,CAA+BF,CAA/B,CAAsCC,EAAtC,CAA6CpD,EAA7C,CAFG,KAIA,CAGL,GAHShD,EAGT,GAHkB,oBAGlB,EAAIkG,CAAMvG,CAAAA,WAAV,CAAuB,MAAO,CAAA,CAC9B,MAAM,KAAIqH,EAAJ,CAAkB,yCAAlB;AAA8DhH,EAA9D,CAAN,CAJK,CAOHkG,CAAM5F,CAAAA,GAAV,GAAkB,IAAlB,EAA0B4F,CAAM5F,CAAAA,GAAhC,GAAwC,GAAxC,GAcE8J,CAYA,CAZSC,SAAA,CACPnE,CAAM5F,CAAAA,GAAN,CAAU,CAAV,CAAA,GAAiB,GAAjB,CAAuB4F,CAAM5F,CAAAA,GAAIG,CAAAA,KAAV,CAAgB,CAAhB,CAAvB,CAA4CyF,CAAM5F,CAAAA,GAD3C,CAEPqG,CAAAA,OAFO,CAEC,IAFD,CAEO,KAFP,CAYT,CAPEyD,CAOF,CARIlE,CAAM5F,CAAAA,GAAN,CAAU,CAAV,CAAJ,GAAqB,GAArB,CACW,GADX,CACiB8J,CADjB,CAEWA,CAAO3J,CAAAA,KAAP,CAAa,CAAb,CAAgB,EAAhB,CAAJ,GAA4B,oBAA5B,CACI,IADJ,CACW2J,CAAO3J,CAAAA,KAAP,CAAa,EAAb,CADX,CAGI,OAHJ,CAGW2J,CAHX,CAGoB,MAG3B,CAAAlE,CAAMG,CAAAA,IAAN,CAAa+D,CAAb,CAAsB,GAAtB,CAA4BlE,CAAMG,CAAAA,IA1BpC,CA3CK,CAyEP,MAAO,CAAA,CAxGmE,CAyH5EiE,QAASA,GAAW,CAAC7B,CAAD,CAAS8B,CAAT,CAAkBC,EAAlB,CAAqC,CAAA,IAGnDzK,EAEJ,IAAI0I,CAAJ,GAAe,IAAf,EAAuB,MAAOA,EAA9B,GAAyC,QAAzC,CAAmD,CACjD,IAAApI,GAAQkK,CAAQhI,CAAAA,OAAR,CAAgBkG,CAAhB,CACR,IAAIpI,EAAJ,GAAc,CAAC,CAAf,CACMmK,EAAkBjI,CAAAA,OAAlB,CAA0BlC,EAA1B,CAAJ,GAAyC,CAAC,CAA1C,EACEmK,EAAkBC,CAAAA,IAAlB,CAAuBpK,EAAvB,CAFJ,KAOE,IAFAkK,CAAQE,CAAAA,IAAR,CAAahC,CAAb,CAEI,CAAAiC,KAAMC,CAAAA,OAAN,CAAclC,CAAd,CAAJ,CACE,IAAKpI,EAAW,CAAH,CAAG,CAAAN,EAAA,CAAS0I,CAAO1I,CAAAA,MAAhC,CAAwCM,EAAxC,CAAgDN,EAAhD,CAAwDM,EAAxD,EAAiE,CAAjE,CACEiK,EAAA,CAAY7B,CAAA,CAAOpI,EAAP,CAAZ,CAA2BkK,CAA3B,CAAoCC,EAApC,CAFJ,KAIO,CACL,IAAAV,GAAgB1J,MAAOD,CAAAA,IAAP,CAAYsI,CAAZ,CAEXpI,GAAA,CAAQ,CAAb,KAAgBN,EAAhB,CAAyB+J,EAAc/J,CAAAA,MAAvC,CAA+CM,EAA/C,CAAuDN,EAAvD,CAA+DM,EAA/D,EAAwE,CAAxE,CACEiK,EAAA,CAAY7B,CAAA,CAAOqB,EAAA,CAAczJ,EAAd,CAAP,CAAZ;AAA0CkK,CAA1C,CAAmDC,EAAnD,CAJG,CAbwC,CALI,CAj5BzD,IAAI3K,GAAsBb,CAAA,CAAQ,CAAR,CAA1B,CACIgI,GAAsBhI,CAAA,CAAQ,CAAR,CAD1B,CAEIM,GAAsBN,CAAA,CAAQ,EAAR,CAF1B,CAIIwK,EAAkBpJ,MAAOwK,CAAAA,SAAUvC,CAAAA,QAJvC,CAKI1H,GAAkBP,MAAOwK,CAAAA,SAAUC,CAAAA,cALvC,CAiCI1C,GAAmB,CAEvB,EAA2B,KAFJ,CAGvB,EAA2B,KAHJ,CAIvB,EAA2B,KAJJ,CAKvB,EAA2B,KALJ,CAMvB,GAA2B,KANJ,CAOvB,GAA2B,KAPJ,CAQvB,GAA2B,KARJ,CASvB,GAA2B,KATJ,CAUvB,GAA2B,KAVJ,CAWvB,GAA2B,KAXJ,CAYvB,GAA2B,MAZJ,CAavB,IAA2B,KAbJ,CAcvB,IAA2B,KAdJ,CAevB,KAA2B,KAfJ,CAgBvB,KAA2B,KAhBJ,CAjCvB,CAmDI7B,GAA6B,mDAAA,CAAA,KAAA,CAAA,GAAA,CAnDjC,CAwDIC,GAA2B,2CAw4B/BtH,GAAOC,CAAAA,OAAQmH,CAAAA,IAAf,CAlBAA,QAAa,CAACyE,CAAD,CAAQ1L,CAAR,CAAiB,CAC5BA,CAAA,CAAUA,CAAV,EAAqB,EAEjB8G,EAAAA,CAAQ,IAAI/G,CAAJ,CAAUC,CAAV,CAEZ,IAAI,CAAC8G,CAAMjF,CAAAA,MAAX,CAAmB,CAhD0B,IACzCsJ,GAAU,EAD+B,CAEzCC,GAAoB,EAFqB,CAIzCzK,EAEJuK,GAAA,CA0C0CQ,CA1C1C,CAAoBP,EAApB,CAA6BC,EAA7B,CAEK,KAAAnK,GAAQ,CAAb,KAAgBN,EAAhB,CAAyByK,EAAkBzK,CAAAA,MAA3C,CAAmDM,EAAnD,CAA2DN,EAA3D,CAAmEM,EAAnE,EAA4E,CAA5E,CAwCiD6F,CAvCzCrE,CAAAA,UAAW4I,CAAAA,IAAjB,CAAsBF,EAAA,CAAQC,EAAA,CAAkBnK,EAAlB,CAAR,CAAtB,CAuC+C6F;CArC3CpE,CAAAA,cAAN,CAA2B4I,KAAJ,CAAU3K,EAAV,CAqCJ,CAIfmG,CAAM1E,CAAAA,QAAV,GACEqH,CADF,CACU3C,CAAM1E,CAAAA,QAASZ,CAAAA,IAAf,CAAoB,CAAE,GAAIiI,CAAN,CAApB,CAAmC,EAAnC,CAAuCA,CAAvC,CADV,CAIA,OAAIC,GAAA,CAAU5C,CAAV,CAAiB,CAAjB,CAAoB2C,CAApB,CAA2B,CAAA,CAA3B,CAAiC,CAAA,CAAjC,CAAJ,CAAmD3C,CAAMG,CAAAA,IAAzD,CAAgE,IAAhE,CAEO,EAfqB,CAn7BwB;\",\n\"sources\":[\"node_modules/js-yaml/lib/dumper.js\"],\n\"sourcesContent\":[\"shadow$provide[30] = function(require,module,exports) {\\n'use strict';\\n\\n/*eslint-disable no-use-before-define*/\\n\\nvar common              = require('./common');\\nvar YAMLException       = require('./exception');\\nvar DEFAULT_SCHEMA      = require('./schema/default');\\n\\nvar _toString       = Object.prototype.toString;\\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\\n\\nvar CHAR_BOM                  = 0xFEFF;\\nvar CHAR_TAB                  = 0x09; /* Tab */\\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\\nvar CHAR_SPACE                = 0x20; /* Space */\\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \\\" */\\nvar CHAR_SHARP                = 0x23; /* # */\\nvar CHAR_PERCENT              = 0x25; /* % */\\nvar CHAR_AMPERSAND            = 0x26; /* & */\\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\\nvar CHAR_ASTERISK             = 0x2A; /* * */\\nvar CHAR_COMMA                = 0x2C; /* , */\\nvar CHAR_MINUS                = 0x2D; /* - */\\nvar CHAR_COLON                = 0x3A; /* : */\\nvar CHAR_EQUALS               = 0x3D; /* = */\\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\\nvar CHAR_QUESTION             = 0x3F; /* ? */\\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\\n\\nvar ESCAPE_SEQUENCES = {};\\n\\nESCAPE_SEQUENCES[0x00]   = '\\\\\\\\0';\\nESCAPE_SEQUENCES[0x07]   = '\\\\\\\\a';\\nESCAPE_SEQUENCES[0x08]   = '\\\\\\\\b';\\nESCAPE_SEQUENCES[0x09]   = '\\\\\\\\t';\\nESCAPE_SEQUENCES[0x0A]   = '\\\\\\\\n';\\nESCAPE_SEQUENCES[0x0B]   = '\\\\\\\\v';\\nESCAPE_SEQUENCES[0x0C]   = '\\\\\\\\f';\\nESCAPE_SEQUENCES[0x0D]   = '\\\\\\\\r';\\nESCAPE_SEQUENCES[0x1B]   = '\\\\\\\\e';\\nESCAPE_SEQUENCES[0x22]   = '\\\\\\\\\\\"';\\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\\\\\\\\\';\\nESCAPE_SEQUENCES[0x85]   = '\\\\\\\\N';\\nESCAPE_SEQUENCES[0xA0]   = '\\\\\\\\_';\\nESCAPE_SEQUENCES[0x2028] = '\\\\\\\\L';\\nESCAPE_SEQUENCES[0x2029] = '\\\\\\\\P';\\n\\nvar DEPRECATED_BOOLEANS_SYNTAX = [\\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\\n];\\n\\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\\\.[0-9_]*)?$/;\\n\\nfunction compileStyleMap(schema, map) {\\n  var result, keys, index, length, tag, style, type;\\n\\n  if (map === null) return {};\\n\\n  result = {};\\n  keys = Object.keys(map);\\n\\n  for (index = 0, length = keys.length; index < length; index += 1) {\\n    tag = keys[index];\\n    style = String(map[tag]);\\n\\n    if (tag.slice(0, 2) === '!!') {\\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\\n    }\\n    type = schema.compiledTypeMap['fallback'][tag];\\n\\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\\n      style = type.styleAliases[style];\\n    }\\n\\n    result[tag] = style;\\n  }\\n\\n  return result;\\n}\\n\\nfunction encodeHex(character) {\\n  var string, handle, length;\\n\\n  string = character.toString(16).toUpperCase();\\n\\n  if (character <= 0xFF) {\\n    handle = 'x';\\n    length = 2;\\n  } else if (character <= 0xFFFF) {\\n    handle = 'u';\\n    length = 4;\\n  } else if (character <= 0xFFFFFFFF) {\\n    handle = 'U';\\n    length = 8;\\n  } else {\\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\\n  }\\n\\n  return '\\\\\\\\' + handle + common.repeat('0', length - string.length) + string;\\n}\\n\\n\\nvar QUOTING_TYPE_SINGLE = 1,\\n    QUOTING_TYPE_DOUBLE = 2;\\n\\nfunction State(options) {\\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\\n  this.indent        = Math.max(1, (options['indent'] || 2));\\n  this.noArrayIndent = options['noArrayIndent'] || false;\\n  this.skipInvalid   = options['skipInvalid'] || false;\\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\\n  this.sortKeys      = options['sortKeys'] || false;\\n  this.lineWidth     = options['lineWidth'] || 80;\\n  this.noRefs        = options['noRefs'] || false;\\n  this.noCompatMode  = options['noCompatMode'] || false;\\n  this.condenseFlow  = options['condenseFlow'] || false;\\n  this.quotingType   = options['quotingType'] === '\\\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\\n  this.forceQuotes   = options['forceQuotes'] || false;\\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\\n\\n  this.implicitTypes = this.schema.compiledImplicit;\\n  this.explicitTypes = this.schema.compiledExplicit;\\n\\n  this.tag = null;\\n  this.result = '';\\n\\n  this.duplicates = [];\\n  this.usedDuplicates = null;\\n}\\n\\n// Indents every line in a string. Empty lines (\\\\n only) are not indented.\\nfunction indentString(string, spaces) {\\n  var ind = common.repeat(' ', spaces),\\n      position = 0,\\n      next = -1,\\n      result = '',\\n      line,\\n      length = string.length;\\n\\n  while (position < length) {\\n    next = string.indexOf('\\\\n', position);\\n    if (next === -1) {\\n      line = string.slice(position);\\n      position = length;\\n    } else {\\n      line = string.slice(position, next + 1);\\n      position = next + 1;\\n    }\\n\\n    if (line.length && line !== '\\\\n') result += ind;\\n\\n    result += line;\\n  }\\n\\n  return result;\\n}\\n\\nfunction generateNextLine(state, level) {\\n  return '\\\\n' + common.repeat(' ', state.indent * level);\\n}\\n\\nfunction testImplicitResolving(state, str) {\\n  var index, length, type;\\n\\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\\n    type = state.implicitTypes[index];\\n\\n    if (type.resolve(str)) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\n// [33] s-white ::= s-space | s-tab\\nfunction isWhitespace(c) {\\n  return c === CHAR_SPACE || c === CHAR_TAB;\\n}\\n\\n// Returns true if the character can be printed without escaping.\\n// From YAML 1.2: \\\"any allowed characters known to be non-printable\\n// should also be escaped. [However,] This isn\\u2019t mandatory\\\"\\n// Derived from nb-char - \\\\t - #x85 - #xA0 - #x2028 - #x2029.\\nfunction isPrintable(c) {\\n  return  (0x00020 <= c && c <= 0x00007E)\\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\\n      ||  (0x10000 <= c && c <= 0x10FFFF);\\n}\\n\\n// [34] ns-char ::= nb-char - s-white\\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\\n// [26] b-char  ::= b-line-feed | b-carriage-return\\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\\nfunction isNsCharOrWhitespace(c) {\\n  return isPrintable(c)\\n    && c !== CHAR_BOM\\n    // - b-char\\n    && c !== CHAR_CARRIAGE_RETURN\\n    && c !== CHAR_LINE_FEED;\\n}\\n\\n// [127]  ns-plain-safe(c) ::= c = flow-out  \\u21d2 ns-plain-safe-out\\n//                             c = flow-in   \\u21d2 ns-plain-safe-in\\n//                             c = block-key \\u21d2 ns-plain-safe-out\\n//                             c = flow-key  \\u21d2 ns-plain-safe-in\\n// [128] ns-plain-safe-out ::= ns-char\\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - \\u201c:\\u201d - \\u201c#\\u201d )\\n//                            | ( /* An ns-char preceding */ \\u201c#\\u201d )\\n//                            | ( \\u201c:\\u201d /* Followed by an ns-plain-safe(c) */ )\\nfunction isPlainSafe(c, prev, inblock) {\\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\\n  return (\\n    // ns-plain-safe\\n    inblock ? // c = flow-in\\n      cIsNsCharOrWhitespace\\n      : cIsNsCharOrWhitespace\\n        // - c-flow-indicator\\n        && c !== CHAR_COMMA\\n        && c !== CHAR_LEFT_SQUARE_BRACKET\\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\\n        && c !== CHAR_LEFT_CURLY_BRACKET\\n        && c !== CHAR_RIGHT_CURLY_BRACKET\\n  )\\n    // ns-plain-char\\n    && c !== CHAR_SHARP // false on '#'\\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\\n}\\n\\n// Simplified test for values allowed as the first character in plain style.\\nfunction isPlainSafeFirst(c) {\\n  // Uses a subset of ns-char - c-indicator\\n  // where ns-char = nb-char - s-white.\\n  // No support of ( ( \\u201c?\\u201d | \\u201c:\\u201d | \\u201c-\\u201d ) /* Followed by an ns-plain-safe(c)) */ ) part\\n  return isPrintable(c) && c !== CHAR_BOM\\n    && !isWhitespace(c) // - s-white\\n    // - (c-indicator ::=\\n    // \\u201c-\\u201d | \\u201c?\\u201d | \\u201c:\\u201d | \\u201c,\\u201d | \\u201c[\\u201d | \\u201c]\\u201d | \\u201c{\\u201d | \\u201c}\\u201d\\n    && c !== CHAR_MINUS\\n    && c !== CHAR_QUESTION\\n    && c !== CHAR_COLON\\n    && c !== CHAR_COMMA\\n    && c !== CHAR_LEFT_SQUARE_BRACKET\\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\\n    && c !== CHAR_LEFT_CURLY_BRACKET\\n    && c !== CHAR_RIGHT_CURLY_BRACKET\\n    // | \\u201c#\\u201d | \\u201c&\\u201d | \\u201c*\\u201d | \\u201c!\\u201d | \\u201c|\\u201d | \\u201c=\\u201d | \\u201c>\\u201d | \\u201c'\\u201d | \\u201c\\\"\\u201d\\n    && c !== CHAR_SHARP\\n    && c !== CHAR_AMPERSAND\\n    && c !== CHAR_ASTERISK\\n    && c !== CHAR_EXCLAMATION\\n    && c !== CHAR_VERTICAL_LINE\\n    && c !== CHAR_EQUALS\\n    && c !== CHAR_GREATER_THAN\\n    && c !== CHAR_SINGLE_QUOTE\\n    && c !== CHAR_DOUBLE_QUOTE\\n    // | \\u201c%\\u201d | \\u201c@\\u201d | \\u201c`\\u201d)\\n    && c !== CHAR_PERCENT\\n    && c !== CHAR_COMMERCIAL_AT\\n    && c !== CHAR_GRAVE_ACCENT;\\n}\\n\\n// Simplified test for values allowed as the last character in plain style.\\nfunction isPlainSafeLast(c) {\\n  // just not whitespace or colon, it will be checked to be plain character later\\n  return !isWhitespace(c) && c !== CHAR_COLON;\\n}\\n\\n// Same as 'string'.codePointAt(pos), but works in older browsers.\\nfunction codePointAt(string, pos) {\\n  var first = string.charCodeAt(pos), second;\\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\\n    second = string.charCodeAt(pos + 1);\\n    if (second >= 0xDC00 && second <= 0xDFFF) {\\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\\n    }\\n  }\\n  return first;\\n}\\n\\n// Determines whether block indentation indicator is required.\\nfunction needIndentIndicator(string) {\\n  var leadingSpaceRe = /^\\\\n* /;\\n  return leadingSpaceRe.test(string);\\n}\\n\\nvar STYLE_PLAIN   = 1,\\n    STYLE_SINGLE  = 2,\\n    STYLE_LITERAL = 3,\\n    STYLE_FOLDED  = 4,\\n    STYLE_DOUBLE  = 5;\\n\\n// Determines which scalar styles are possible and returns the preferred style.\\n// lineWidth = -1 => no limit.\\n// Pre-conditions: str.length > 0.\\n// Post-conditions:\\n//    STYLE_PLAIN or STYLE_SINGLE => no \\\\n are in the string.\\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\\n\\n  var i;\\n  var char = 0;\\n  var prevChar = null;\\n  var hasLineBreak = false;\\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\\n  var shouldTrackWidth = lineWidth !== -1;\\n  var previousLineBreak = -1; // count the first line correctly\\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\\n\\n  if (singleLineOnly || forceQuotes) {\\n    // Case: no block styles.\\n    // Check for disallowed characters to rule out plain and single.\\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\\n      char = codePointAt(string, i);\\n      if (!isPrintable(char)) {\\n        return STYLE_DOUBLE;\\n      }\\n      plain = plain && isPlainSafe(char, prevChar, inblock);\\n      prevChar = char;\\n    }\\n  } else {\\n    // Case: block styles permitted.\\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\\n      char = codePointAt(string, i);\\n      if (char === CHAR_LINE_FEED) {\\n        hasLineBreak = true;\\n        // Check if any line can be folded.\\n        if (shouldTrackWidth) {\\n          hasFoldableLine = hasFoldableLine ||\\n            // Foldable line = too long, and not more-indented.\\n            (i - previousLineBreak - 1 > lineWidth &&\\n             string[previousLineBreak + 1] !== ' ');\\n          previousLineBreak = i;\\n        }\\n      } else if (!isPrintable(char)) {\\n        return STYLE_DOUBLE;\\n      }\\n      plain = plain && isPlainSafe(char, prevChar, inblock);\\n      prevChar = char;\\n    }\\n    // in case the end is missing a \\\\n\\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\\n      (i - previousLineBreak - 1 > lineWidth &&\\n       string[previousLineBreak + 1] !== ' '));\\n  }\\n  // Although every style can represent \\\\n without escaping, prefer block styles\\n  // for multiline, since they're more readable and they don't add empty lines.\\n  // Also prefer folding a super-long line.\\n  if (!hasLineBreak && !hasFoldableLine) {\\n    // Strings interpretable as another type have to be quoted;\\n    // e.g. the string 'true' vs. the boolean true.\\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\\n      return STYLE_PLAIN;\\n    }\\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\\n  }\\n  // Edge case: block indentation indicator can only have one digit.\\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\\n    return STYLE_DOUBLE;\\n  }\\n  // At this point we know block styles are valid.\\n  // Prefer literal style unless we want to fold.\\n  if (!forceQuotes) {\\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\\n  }\\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\\n}\\n\\n// Note: line breaking/folding is implemented for only the folded style.\\n// NB. We drop the last trailing newline (if any) of a returned block scalar\\n//  since the dumper adds its own newline. This always works:\\n//    \\u2022 No ending newline => unaffected; already using strip \\\"-\\\" chomping.\\n//    \\u2022 Ending newline    => removed then restored.\\n//  Importantly, this keeps the \\\"+\\\" chomp indicator from gaining an extra line.\\nfunction writeScalar(state, string, level, iskey, inblock) {\\n  state.dump = (function () {\\n    if (string.length === 0) {\\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\\\"\\\"' : \\\"''\\\";\\n    }\\n    if (!state.noCompatMode) {\\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\\\"' + string + '\\\"') : (\\\"'\\\" + string + \\\"'\\\");\\n      }\\n    }\\n\\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\\n    // As indentation gets deeper, let the width decrease monotonically\\n    // to the lower bound min(state.lineWidth, 40).\\n    // Note that this implies\\n    //  state.lineWidth \\u2264 40 + state.indent: width is fixed at the lower bound.\\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\\n    // This behaves better than a constant minimum width which disallows narrower options,\\n    // or an indent threshold which causes the width to suddenly increase.\\n    var lineWidth = state.lineWidth === -1\\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\\n\\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\\n    var singleLineOnly = iskey\\n      // No block styles in flow mode.\\n      || (state.flowLevel > -1 && level >= state.flowLevel);\\n    function testAmbiguity(string) {\\n      return testImplicitResolving(state, string);\\n    }\\n\\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\\n\\n      case STYLE_PLAIN:\\n        return string;\\n      case STYLE_SINGLE:\\n        return \\\"'\\\" + string.replace(/'/g, \\\"''\\\") + \\\"'\\\";\\n      case STYLE_LITERAL:\\n        return '|' + blockHeader(string, state.indent)\\n          + dropEndingNewline(indentString(string, indent));\\n      case STYLE_FOLDED:\\n        return '>' + blockHeader(string, state.indent)\\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\\n      case STYLE_DOUBLE:\\n        return '\\\"' + escapeString(string, lineWidth) + '\\\"';\\n      default:\\n        throw new YAMLException('impossible error: invalid scalar style');\\n    }\\n  }());\\n}\\n\\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\\nfunction blockHeader(string, indentPerLevel) {\\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\\n\\n  // note the special case: the string '\\\\n' counts as a \\\"trailing\\\" empty line.\\n  var clip =          string[string.length - 1] === '\\\\n';\\n  var keep = clip && (string[string.length - 2] === '\\\\n' || string === '\\\\n');\\n  var chomp = keep ? '+' : (clip ? '' : '-');\\n\\n  return indentIndicator + chomp + '\\\\n';\\n}\\n\\n// (See the note for writeScalar.)\\nfunction dropEndingNewline(string) {\\n  return string[string.length - 1] === '\\\\n' ? string.slice(0, -1) : string;\\n}\\n\\n// Note: a long line without a suitable break point will exceed the width limit.\\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\\nfunction foldString(string, width) {\\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\\u2014\\n  // unless they're before or after a more-indented line, or at the very\\n  // beginning or end, in which case $k$ maps to $k$.\\n  // Therefore, parse each chunk as newline(s) followed by a content line.\\n  var lineRe = /(\\\\n+)([^\\\\n]*)/g;\\n\\n  // first line (possibly an empty line)\\n  var result = (function () {\\n    var nextLF = string.indexOf('\\\\n');\\n    nextLF = nextLF !== -1 ? nextLF : string.length;\\n    lineRe.lastIndex = nextLF;\\n    return foldLine(string.slice(0, nextLF), width);\\n  }());\\n  // If we haven't reached the first content line yet, don't add an extra \\\\n.\\n  var prevMoreIndented = string[0] === '\\\\n' || string[0] === ' ';\\n  var moreIndented;\\n\\n  // rest of the lines\\n  var match;\\n  while ((match = lineRe.exec(string))) {\\n    var prefix = match[1], line = match[2];\\n    moreIndented = (line[0] === ' ');\\n    result += prefix\\n      + (!prevMoreIndented && !moreIndented && line !== ''\\n        ? '\\\\n' : '')\\n      + foldLine(line, width);\\n    prevMoreIndented = moreIndented;\\n  }\\n\\n  return result;\\n}\\n\\n// Greedy line breaking.\\n// Picks the longest line under the limit each time,\\n// otherwise settles for the shortest line over the limit.\\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\\\n.\\nfunction foldLine(line, width) {\\n  if (line === '' || line[0] === ' ') return line;\\n\\n  // Since a more-indented line adds a \\\\n, breaks can't be followed by a space.\\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\\n  var match;\\n  // start is an inclusive index. end, curr, and next are exclusive.\\n  var start = 0, end, curr = 0, next = 0;\\n  var result = '';\\n\\n  // Invariants: 0 <= start <= length-1.\\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\\n  // Inside the loop:\\n  //   A match implies length >= 2, so curr and next are <= length-2.\\n  while ((match = breakRe.exec(line))) {\\n    next = match.index;\\n    // maintain invariant: curr - start <= width\\n    if (next - start > width) {\\n      end = (curr > start) ? curr : next; // derive end <= length-2\\n      result += '\\\\n' + line.slice(start, end);\\n      // skip the space that was output as \\\\n\\n      start = end + 1;                    // derive start <= length-1\\n    }\\n    curr = next;\\n  }\\n\\n  // By the invariants, start <= length-1, so there is something left over.\\n  // It is either the whole string or a part starting from non-whitespace.\\n  result += '\\\\n';\\n  // Insert a break if the remainder is too long and there is a break available.\\n  if (line.length - start > width && curr > start) {\\n    result += line.slice(start, curr) + '\\\\n' + line.slice(curr + 1);\\n  } else {\\n    result += line.slice(start);\\n  }\\n\\n  return result.slice(1); // drop extra \\\\n joiner\\n}\\n\\n// Escapes a double-quoted string.\\nfunction escapeString(string) {\\n  var result = '';\\n  var char = 0;\\n  var escapeSeq;\\n\\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\\n    char = codePointAt(string, i);\\n    escapeSeq = ESCAPE_SEQUENCES[char];\\n\\n    if (!escapeSeq && isPrintable(char)) {\\n      result += string[i];\\n      if (char >= 0x10000) result += string[i + 1];\\n    } else {\\n      result += escapeSeq || encodeHex(char);\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nfunction writeFlowSequence(state, level, object) {\\n  var _result = '',\\n      _tag    = state.tag,\\n      index,\\n      length,\\n      value;\\n\\n  for (index = 0, length = object.length; index < length; index += 1) {\\n    value = object[index];\\n\\n    if (state.replacer) {\\n      value = state.replacer.call(object, String(index), value);\\n    }\\n\\n    // Write only valid elements, put null instead of invalid elements.\\n    if (writeNode(state, level, value, false, false) ||\\n        (typeof value === 'undefined' &&\\n         writeNode(state, level, null, false, false))) {\\n\\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\\n      _result += state.dump;\\n    }\\n  }\\n\\n  state.tag = _tag;\\n  state.dump = '[' + _result + ']';\\n}\\n\\nfunction writeBlockSequence(state, level, object, compact) {\\n  var _result = '',\\n      _tag    = state.tag,\\n      index,\\n      length,\\n      value;\\n\\n  for (index = 0, length = object.length; index < length; index += 1) {\\n    value = object[index];\\n\\n    if (state.replacer) {\\n      value = state.replacer.call(object, String(index), value);\\n    }\\n\\n    // Write only valid elements, put null instead of invalid elements.\\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\\n        (typeof value === 'undefined' &&\\n         writeNode(state, level + 1, null, true, true, false, true))) {\\n\\n      if (!compact || _result !== '') {\\n        _result += generateNextLine(state, level);\\n      }\\n\\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\\n        _result += '-';\\n      } else {\\n        _result += '- ';\\n      }\\n\\n      _result += state.dump;\\n    }\\n  }\\n\\n  state.tag = _tag;\\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\\n}\\n\\nfunction writeFlowMapping(state, level, object) {\\n  var _result       = '',\\n      _tag          = state.tag,\\n      objectKeyList = Object.keys(object),\\n      index,\\n      length,\\n      objectKey,\\n      objectValue,\\n      pairBuffer;\\n\\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\\n\\n    pairBuffer = '';\\n    if (_result !== '') pairBuffer += ', ';\\n\\n    if (state.condenseFlow) pairBuffer += '\\\"';\\n\\n    objectKey = objectKeyList[index];\\n    objectValue = object[objectKey];\\n\\n    if (state.replacer) {\\n      objectValue = state.replacer.call(object, objectKey, objectValue);\\n    }\\n\\n    if (!writeNode(state, level, objectKey, false, false)) {\\n      continue; // Skip this pair because of invalid key;\\n    }\\n\\n    if (state.dump.length > 1024) pairBuffer += '? ';\\n\\n    pairBuffer += state.dump + (state.condenseFlow ? '\\\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\\n\\n    if (!writeNode(state, level, objectValue, false, false)) {\\n      continue; // Skip this pair because of invalid value.\\n    }\\n\\n    pairBuffer += state.dump;\\n\\n    // Both key and value are valid.\\n    _result += pairBuffer;\\n  }\\n\\n  state.tag = _tag;\\n  state.dump = '{' + _result + '}';\\n}\\n\\nfunction writeBlockMapping(state, level, object, compact) {\\n  var _result       = '',\\n      _tag          = state.tag,\\n      objectKeyList = Object.keys(object),\\n      index,\\n      length,\\n      objectKey,\\n      objectValue,\\n      explicitPair,\\n      pairBuffer;\\n\\n  // Allow sorting keys so that the output file is deterministic\\n  if (state.sortKeys === true) {\\n    // Default sorting\\n    objectKeyList.sort();\\n  } else if (typeof state.sortKeys === 'function') {\\n    // Custom sort function\\n    objectKeyList.sort(state.sortKeys);\\n  } else if (state.sortKeys) {\\n    // Something is wrong\\n    throw new YAMLException('sortKeys must be a boolean or a function');\\n  }\\n\\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\\n    pairBuffer = '';\\n\\n    if (!compact || _result !== '') {\\n      pairBuffer += generateNextLine(state, level);\\n    }\\n\\n    objectKey = objectKeyList[index];\\n    objectValue = object[objectKey];\\n\\n    if (state.replacer) {\\n      objectValue = state.replacer.call(object, objectKey, objectValue);\\n    }\\n\\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\\n      continue; // Skip this pair because of invalid key.\\n    }\\n\\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\\n                   (state.dump && state.dump.length > 1024);\\n\\n    if (explicitPair) {\\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\\n        pairBuffer += '?';\\n      } else {\\n        pairBuffer += '? ';\\n      }\\n    }\\n\\n    pairBuffer += state.dump;\\n\\n    if (explicitPair) {\\n      pairBuffer += generateNextLine(state, level);\\n    }\\n\\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\\n      continue; // Skip this pair because of invalid value.\\n    }\\n\\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\\n      pairBuffer += ':';\\n    } else {\\n      pairBuffer += ': ';\\n    }\\n\\n    pairBuffer += state.dump;\\n\\n    // Both key and value are valid.\\n    _result += pairBuffer;\\n  }\\n\\n  state.tag = _tag;\\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\\n}\\n\\nfunction detectType(state, object, explicit) {\\n  var _result, typeList, index, length, type, style;\\n\\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\\n\\n  for (index = 0, length = typeList.length; index < length; index += 1) {\\n    type = typeList[index];\\n\\n    if ((type.instanceOf  || type.predicate) &&\\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\\n        (!type.predicate  || type.predicate(object))) {\\n\\n      if (explicit) {\\n        if (type.multi && type.representName) {\\n          state.tag = type.representName(object);\\n        } else {\\n          state.tag = type.tag;\\n        }\\n      } else {\\n        state.tag = '?';\\n      }\\n\\n      if (type.represent) {\\n        style = state.styleMap[type.tag] || type.defaultStyle;\\n\\n        if (_toString.call(type.represent) === '[object Function]') {\\n          _result = type.represent(object, style);\\n        } else if (_hasOwnProperty.call(type.represent, style)) {\\n          _result = type.represent[style](object, style);\\n        } else {\\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \\\"' + style + '\\\" style');\\n        }\\n\\n        state.dump = _result;\\n      }\\n\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\n// Serializes `object` and writes it to global `result`.\\n// Returns true on success, or false on invalid object.\\n//\\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\\n  state.tag = null;\\n  state.dump = object;\\n\\n  if (!detectType(state, object, false)) {\\n    detectType(state, object, true);\\n  }\\n\\n  var type = _toString.call(state.dump);\\n  var inblock = block;\\n  var tagStr;\\n\\n  if (block) {\\n    block = (state.flowLevel < 0 || state.flowLevel > level);\\n  }\\n\\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\\n      duplicateIndex,\\n      duplicate;\\n\\n  if (objectOrArray) {\\n    duplicateIndex = state.duplicates.indexOf(object);\\n    duplicate = duplicateIndex !== -1;\\n  }\\n\\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\\n    compact = false;\\n  }\\n\\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\\n    state.dump = '*ref_' + duplicateIndex;\\n  } else {\\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\\n      state.usedDuplicates[duplicateIndex] = true;\\n    }\\n    if (type === '[object Object]') {\\n      if (block && (Object.keys(state.dump).length !== 0)) {\\n        writeBlockMapping(state, level, state.dump, compact);\\n        if (duplicate) {\\n          state.dump = '&ref_' + duplicateIndex + state.dump;\\n        }\\n      } else {\\n        writeFlowMapping(state, level, state.dump);\\n        if (duplicate) {\\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\\n        }\\n      }\\n    } else if (type === '[object Array]') {\\n      if (block && (state.dump.length !== 0)) {\\n        if (state.noArrayIndent && !isblockseq && level > 0) {\\n          writeBlockSequence(state, level - 1, state.dump, compact);\\n        } else {\\n          writeBlockSequence(state, level, state.dump, compact);\\n        }\\n        if (duplicate) {\\n          state.dump = '&ref_' + duplicateIndex + state.dump;\\n        }\\n      } else {\\n        writeFlowSequence(state, level, state.dump);\\n        if (duplicate) {\\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\\n        }\\n      }\\n    } else if (type === '[object String]') {\\n      if (state.tag !== '?') {\\n        writeScalar(state, state.dump, level, iskey, inblock);\\n      }\\n    } else if (type === '[object Undefined]') {\\n      return false;\\n    } else {\\n      if (state.skipInvalid) return false;\\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\\n    }\\n\\n    if (state.tag !== null && state.tag !== '?') {\\n      // Need to encode all characters except those allowed by the spec:\\n      //\\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\\n      // [36] ns-hex-digit    ::=  ns-dec-digit\\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | \\u201c-\\u201d\\n      // [39] ns-uri-char     ::=  \\u201c%\\u201d ns-hex-digit ns-hex-digit | ns-word-char | \\u201c#\\u201d\\n      //                         | \\u201c;\\u201d | \\u201c/\\u201d | \\u201c?\\u201d | \\u201c:\\u201d | \\u201c@\\u201d | \\u201c&\\u201d | \\u201c=\\u201d | \\u201c+\\u201d | \\u201c$\\u201d | \\u201c,\\u201d\\n      //                         | \\u201c_\\u201d | \\u201c.\\u201d | \\u201c!\\u201d | \\u201c~\\u201d | \\u201c*\\u201d | \\u201c'\\u201d | \\u201c(\\u201d | \\u201c)\\u201d | \\u201c[\\u201d | \\u201c]\\u201d\\n      //\\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\\n      //\\n      tagStr = encodeURI(\\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\\n      ).replace(/!/g, '%21');\\n\\n      if (state.tag[0] === '!') {\\n        tagStr = '!' + tagStr;\\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\\n        tagStr = '!!' + tagStr.slice(18);\\n      } else {\\n        tagStr = '!<' + tagStr + '>';\\n      }\\n\\n      state.dump = tagStr + ' ' + state.dump;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nfunction getDuplicateReferences(object, state) {\\n  var objects = [],\\n      duplicatesIndexes = [],\\n      index,\\n      length;\\n\\n  inspectNode(object, objects, duplicatesIndexes);\\n\\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\\n  }\\n  state.usedDuplicates = new Array(length);\\n}\\n\\nfunction inspectNode(object, objects, duplicatesIndexes) {\\n  var objectKeyList,\\n      index,\\n      length;\\n\\n  if (object !== null && typeof object === 'object') {\\n    index = objects.indexOf(object);\\n    if (index !== -1) {\\n      if (duplicatesIndexes.indexOf(index) === -1) {\\n        duplicatesIndexes.push(index);\\n      }\\n    } else {\\n      objects.push(object);\\n\\n      if (Array.isArray(object)) {\\n        for (index = 0, length = object.length; index < length; index += 1) {\\n          inspectNode(object[index], objects, duplicatesIndexes);\\n        }\\n      } else {\\n        objectKeyList = Object.keys(object);\\n\\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nfunction dump(input, options) {\\n  options = options || {};\\n\\n  var state = new State(options);\\n\\n  if (!state.noRefs) getDuplicateReferences(input, state);\\n\\n  var value = input;\\n\\n  if (state.replacer) {\\n    value = state.replacer.call({ '': value }, '', value);\\n  }\\n\\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\\\n';\\n\\n  return '';\\n}\\n\\nmodule.exports.dump = dump;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"State\",\"options\",\"schema\",\"DEFAULT_SCHEMA\",\"indent\",\"Math\",\"max\",\"noArrayIndent\",\"skipInvalid\",\"flowLevel\",\"common\",\"isNothing\",\"length\",\"type\",\"map\",\"result\",\"keys\",\"Object\",\"index\",\"tag\",\"style\",\"String\",\"slice\",\"compiledTypeMap\",\"_hasOwnProperty\",\"call\",\"styleAliases\",\"styleMap\",\"sortKeys\",\"lineWidth\",\"noRefs\",\"noCompatMode\",\"condenseFlow\",\"quotingType\",\"QUOTING_TYPE_DOUBLE\",\"QUOTING_TYPE_SINGLE\",\"forceQuotes\",\"replacer\",\"implicitTypes\",\"compiledImplicit\",\"explicitTypes\",\"compiledExplicit\",\"duplicates\",\"usedDuplicates\",\"indentString\",\"string\",\"spaces\",\"ind\",\"repeat\",\"position\",\"next\",\"line\",\"indexOf\",\"isPrintable\",\"c\",\"CHAR_BOM\",\"isNsCharOrWhitespace\",\"CHAR_CARRIAGE_RETURN\",\"CHAR_LINE_FEED\",\"isPlainSafe\",\"prev\",\"inblock\",\"cIsNsCharOrWhitespace\",\"cIsNsChar\",\"CHAR_SPACE\",\"CHAR_TAB\",\"CHAR_COMMA\",\"CHAR_LEFT_SQUARE_BRACKET\",\"CHAR_RIGHT_SQUARE_BRACKET\",\"CHAR_LEFT_CURLY_BRACKET\",\"CHAR_RIGHT_CURLY_BRACKET\",\"CHAR_SHARP\",\"CHAR_COLON\",\"codePointAt\",\"pos\",\"first\",\"charCodeAt\",\"second\",\"chooseScalarStyle\",\"singleLineOnly\",\"indentPerLevel\",\"testAmbiguousType\",\"prevChar\",\"hasLineBreak\",\"hasFoldableLine\",\"shouldTrackWidth\",\"previousLineBreak\",\"CHAR_MINUS\",\"CHAR_QUESTION\",\"CHAR_AMPERSAND\",\"CHAR_ASTERISK\",\"CHAR_EXCLAMATION\",\"CHAR_VERTICAL_LINE\",\"CHAR_EQUALS\",\"CHAR_GREATER_THAN\",\"CHAR_SINGLE_QUOTE\",\"CHAR_DOUBLE_QUOTE\",\"CHAR_PERCENT\",\"CHAR_COMMERCIAL_AT\",\"CHAR_GRAVE_ACCENT\",\"i\",\"char\",\"STYLE_DOUBLE\",\"plain\",\"leadingSpaceRe\",\"test\",\"STYLE_SINGLE\",\"STYLE_FOLDED\",\"STYLE_LITERAL\",\"STYLE_PLAIN\",\"writeScalar\",\"state\",\"level\",\"iskey\",\"dump\",\"DEPRECATED_BOOLEANS_SYNTAX\",\"DEPRECATED_BASE60_SYNTAX\",\"min\",\"testAmbiguity\",\"resolve\",\"replace\",\"blockHeader\",\"dropEndingNewline\",\"foldString\",\"escapeString\",\"YAMLException\",\"indentIndicator\",\"clip\",\"chomp\",\"width\",\"lineRe\",\"nextLF\",\"lastIndex\",\"foldLine\",\"prevMoreIndented\",\"moreIndented\",\"match\",\"exec\",\"prefix\",\"breakRe\",\"start\",\"curr\",\"end\",\"escapeSeq\",\"ESCAPE_SEQUENCES\",\"character\",\"toString\",\"toUpperCase\",\"handle\",\"writeBlockSequence\",\"object\",\"compact\",\"_result\",\"_tag\",\"value\",\"writeNode\",\"detectType\",\"explicit\",\"typeList\",\"instanceOf\",\"predicate\",\"multi\",\"representName\",\"represent\",\"defaultStyle\",\"_toString\",\"block\",\"isblockseq\",\"objectOrArray\",\"duplicateIndex\",\"duplicate\",\"objectKeyList\",\"sort\",\"pairBuffer\",\"objectKey\",\"objectValue\",\"explicitPair\",\"tagStr\",\"encodeURI\",\"inspectNode\",\"objects\",\"duplicatesIndexes\",\"push\",\"Array\",\"isArray\",\"prototype\",\"hasOwnProperty\",\"input\"]\n}\n"]
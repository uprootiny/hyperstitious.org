["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/js-yaml/lib/schema.js"],"~:js","shadow$provide[11]=function(P,ta,ka){function V(H,W){var D=[];H[W].forEach(function(F){var U=D.length;D.forEach(function(ha,za){ha.tag===F.tag&&ha.kind===F.kind&&ha.multi===F.multi&&(U=za)});D[U]=F});return D}function J(){function H(U){U.multi?(W.multi[U.kind].push(U),W.multi.fallback.push(U)):W[U.kind][U.tag]=W.fallback[U.tag]=U}var W={scalar:{},sequence:{},mapping:{},fallback:{},multi:{scalar:[],sequence:[],mapping:[],fallback:[]}},D;var F=0;for(D=arguments.length;F<D;F+=1)arguments[F].forEach(H);\nreturn W}function N(H){return this.extend(H)}var L=P(8),I=P(10);N.prototype.extend=function(H){var W=[],D=[];if(H instanceof I)D.push(H);else if(Array.isArray(H))D=D.concat(H);else if(H&&(Array.isArray(H.implicit)||Array.isArray(H.explicit)))H.implicit&&(W=W.concat(H.implicit)),H.explicit&&(D=D.concat(H.explicit));else throw new L(\"Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })\");W.forEach(function(F){if(!(F instanceof I))throw new L(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\nif(F.loadKind&&F.loadKind!==\"scalar\")throw new L(\"There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.\");if(F.multi)throw new L(\"There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.\");});D.forEach(function(F){if(!(F instanceof I))throw new L(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");});H=Object.create(N.prototype);H.implicit=(this.implicit||[]).concat(W);\nH.explicit=(this.explicit||[]).concat(D);H.compiledImplicit=V(H,\"implicit\");H.compiledExplicit=V(H,\"explicit\");H.compiledTypeMap=J(H.compiledImplicit,H.compiledExplicit);return H};ta.exports=N}","~:source","shadow$provide[11] = function(require,module,exports) {\n'use strict';\n\n/*eslint-disable max-len*/\n\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof Type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type.multi) {\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nmodule.exports = Schema;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$js_yaml$lib$type","~$shadow.js","~$module$node_modules$js_yaml$lib$exception"]],"~:properties",["^5",["scalar","compiledExplicit","compiledTypeMap","implicit","compiledImplicit","sequence","explicit","fallback","mapping","extend","multi"]],"~:compiled-at",1751714332113,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$js_yaml$lib$schema.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/js-yaml/lib/schema.js\"],\n\"sourcesContent\":[\"shadow$provide[11] = function(require,module,exports) {\\n'use strict';\\n\\n/*eslint-disable max-len*/\\n\\nvar YAMLException = require('./exception');\\nvar Type          = require('./type');\\n\\n\\nfunction compileList(schema, name) {\\n  var result = [];\\n\\n  schema[name].forEach(function (currentType) {\\n    var newIndex = result.length;\\n\\n    result.forEach(function (previousType, previousIndex) {\\n      if (previousType.tag === currentType.tag &&\\n          previousType.kind === currentType.kind &&\\n          previousType.multi === currentType.multi) {\\n\\n        newIndex = previousIndex;\\n      }\\n    });\\n\\n    result[newIndex] = currentType;\\n  });\\n\\n  return result;\\n}\\n\\n\\nfunction compileMap(/* lists... */) {\\n  var result = {\\n        scalar: {},\\n        sequence: {},\\n        mapping: {},\\n        fallback: {},\\n        multi: {\\n          scalar: [],\\n          sequence: [],\\n          mapping: [],\\n          fallback: []\\n        }\\n      }, index, length;\\n\\n  function collectType(type) {\\n    if (type.multi) {\\n      result.multi[type.kind].push(type);\\n      result.multi['fallback'].push(type);\\n    } else {\\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\\n    }\\n  }\\n\\n  for (index = 0, length = arguments.length; index < length; index += 1) {\\n    arguments[index].forEach(collectType);\\n  }\\n  return result;\\n}\\n\\n\\nfunction Schema(definition) {\\n  return this.extend(definition);\\n}\\n\\n\\nSchema.prototype.extend = function extend(definition) {\\n  var implicit = [];\\n  var explicit = [];\\n\\n  if (definition instanceof Type) {\\n    // Schema.extend(type)\\n    explicit.push(definition);\\n\\n  } else if (Array.isArray(definition)) {\\n    // Schema.extend([ type1, type2, ... ])\\n    explicit = explicit.concat(definition);\\n\\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\\n\\n  } else {\\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +\\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\\n  }\\n\\n  implicit.forEach(function (type) {\\n    if (!(type instanceof Type)) {\\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\\n    }\\n\\n    if (type.loadKind && type.loadKind !== 'scalar') {\\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\\n    }\\n\\n    if (type.multi) {\\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\\n    }\\n  });\\n\\n  explicit.forEach(function (type) {\\n    if (!(type instanceof Type)) {\\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\\n    }\\n  });\\n\\n  var result = Object.create(Schema.prototype);\\n\\n  result.implicit = (this.implicit || []).concat(implicit);\\n  result.explicit = (this.explicit || []).concat(explicit);\\n\\n  result.compiledImplicit = compileList(result, 'implicit');\\n  result.compiledExplicit = compileList(result, 'explicit');\\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\\n\\n  return result;\\n};\\n\\n\\nmodule.exports = Schema;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"compileList\",\"schema\",\"name\",\"result\",\"forEach\",\"currentType\",\"newIndex\",\"length\",\"previousType\",\"previousIndex\",\"tag\",\"kind\",\"multi\",\"compileMap\",\"collectType\",\"type\",\"push\",\"scalar\",\"sequence\",\"mapping\",\"fallback\",\"index\",\"arguments\",\"Schema\",\"definition\",\"extend\",\"YAMLException\",\"Type\",\"prototype\",\"Schema.prototype.extend\",\"implicit\",\"explicit\",\"Array\",\"isArray\",\"concat\",\"loadKind\",\"Object\",\"create\",\"compiledImplicit\",\"compiledExplicit\",\"compiledTypeMap\"]\n}\n"]